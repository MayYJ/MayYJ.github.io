<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.4.2" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.2">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.4.2',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="既然选择了远方，便只顾风雨兼程。">
<meta property="og:type" content="website">
<meta property="og:title" content="May&#39;s Blog">
<meta property="og:url" content="https://github.com/MayYJ/hexo/page/3/index.html">
<meta property="og:site_name" content="May&#39;s Blog">
<meta property="og:description" content="既然选择了远方，便只顾风雨兼程。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="May&#39;s Blog">
<meta name="twitter:description" content="既然选择了远方，便只顾风雨兼程。">






  <link rel="canonical" href="https://github.com/MayYJ/hexo/page/3/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>May's Blog</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">May's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">既然选择了远方，便只顾风雨兼程。</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archieven</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/MayYJ/hexo/2018/05/12/java/java序列化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="May">
      <meta itemprop="description" content="既然选择了远方，便只顾风雨兼程。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="May's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/12/java/java序列化/" itemprop="url">
                  java序列化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Geplaatst op</span>
              

              
                
              

              <time title="Post aangemaakt: 2018-05-12 22:46:12" itemprop="dateCreated datePublished" datetime="2018-05-12T22:46:12+08:00">2018-05-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Post aangepast: 2018-05-26 17:27:55" itemprop="dateModified" datetime="2018-05-26T17:27:55+08:00">2018-05-26</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="为什么要序列化"><a href="#为什么要序列化" class="headerlink" title="为什么要序列化"></a>为什么要序列化</h4><p>当我们创建一个对象后，如果程序终止那么对象就会销毁，但是存在我们需要对对象进行持久化的需求，以便在将来我们取出对象<br>进行再次利用。序列化就是把对象变成字节码序列来实现轻量级持久化，也方便我们对其在网络上进行传输。</p>
<h4 id="怎么序列化"><a href="#怎么序列化" class="headerlink" title="怎么序列化"></a>怎么序列化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class Stu implements Serializable&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private transient String password;</span><br><span class="line"></span><br><span class="line">    public Stu(String name, int age, String password) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPassword(String password) &#123;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestSerializable &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        Stu stu = new Stu(&quot;May&quot;,20, &quot;123456&quot;);</span><br><span class="line">        ObjectOutputStream ops = new ObjectOutputStream(new FileOutputStream(&quot;/home/may/Documents/temp.txt&quot;));</span><br><span class="line">        ops.writeObject(stu);</span><br><span class="line">        ops.close();</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;/home/may/Documents/temp.txt&quot;));</span><br><span class="line">        Stu stu1 = (Stu) ois.readObject();</span><br><span class="line">        System.out.println(stu1.getPassword());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上便是简单的实现对象的序列化，只需要在类上添加Serializable标记接口，然后就可以直接使用ObjectOutputStream和ObjecInputStream对对象进行序列化和反序列化。</p>
<h4 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h4><p>在序列化的时候，有些字段我们不想默认序列化，比如说用户的密码等；这个时候我们就可以使用这个关键字，对标记的字段屏蔽默认序列化。</p>
<h4 id="寻找类"><a href="#寻找类" class="headerlink" title="寻找类"></a>寻找类</h4><p>在我们进行反序列化的时候，被序列化对象的java文件应该在同一个目录下，而且版本相同即在序列化后没有进过修改，不然在反序列化的时候会抛出ClassNotFoundException。</p>
<h4 id="序列化的控制"><a href="#序列化的控制" class="headerlink" title="序列化的控制"></a>序列化的控制</h4><p>有些时候我们不想按照默认的序列化方式进行，我们想定义自己对一个对象的序列化的方式，当然上面transient是一个方式。我们还可以使用Externalizable接口，重载writeExternal和readExternal方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class Stu implements Externalizable&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private transient String password;</span><br><span class="line"></span><br><span class="line">    public Stu(String name, int age, String password) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPassword(String password) &#123;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void writeObject(ObjectOutputStream oos) throws IOException &#123;</span><br><span class="line">        oos.defaultWriteObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        ois.defaultReadObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的defaultReadObject方法就是会采用默认的对象的序列化方式。</p>
<h4 id="Externalizable的替代方案"><a href="#Externalizable的替代方案" class="headerlink" title="Externalizable的替代方案"></a>Externalizable的替代方案</h4><p>直接在实现了Serialization类里面实现下面两个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private void WriterObject()</span><br><span class="line"></span><br><span class="line">private void readObject()</span><br></pre></td></tr></table></figure></p>
<p>在序列化和反序列化的时候在调用ObjectOutputStream.writeObject()和ObjectInputStream.readObject()的时候会检查object是不是有自己的writeObject和readObject方法。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/MayYJ/hexo/2018/05/05/java/java nio/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="May">
      <meta itemprop="description" content="既然选择了远方，便只顾风雨兼程。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="May's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/05/java/java nio/" itemprop="url">
                  nio
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Geplaatst op</span>
              

              
                
              

              <time title="Post aangemaakt: 2018-05-05 17:41:16" itemprop="dateCreated datePublished" datetime="2018-05-05T17:41:16+08:00">2018-05-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Post aangepast: 2018-08-29 14:48:44" itemprop="dateModified" datetime="2018-08-29T14:48:44+08:00">2018-08-29</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="总的"><a href="#总的" class="headerlink" title="总的"></a>总的</h4><h5 id="同步IO"><a href="#同步IO" class="headerlink" title="同步IO"></a>同步IO</h5><p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。 </p>
<p><img src="https://ws1.sinaimg.cn/large/a67bf22fgy1fupj4idh0aj20fw0903zx.jpg" alt=""></p>
<h5 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h5><ul>
<li><p>阻塞</p>
<p>在等待数据就绪和复制数据阶段均阻塞。 </p>
<p><img src="https://ws1.sinaimg.cn/large/a67bf22fgy1fupj6q9kiqj20fc097t8n.jpg" alt=""></p>
</li>
<li><p>非阻塞</p>
<p>在等待数据就绪阶段，如果数据未就绪 read 会立刻返回 error，不阻塞；用户需要轮询以确认数据就绪；当就绪后则复制数据，该过程阻塞。 </p>
<p><img src="https://ws1.sinaimg.cn/large/a67bf22fgy1fupj8sj22xj20gr099aa4.jpg" alt=""></p>
</li>
</ul>
<h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h5><p>实现非阻塞</p>
<p>这个概念稍有不同，它是在执行 select() 的时候，同时阻塞多个 fd 然后等到监测到某些 fd 就绪时返回。此时进程两阶段均被阻塞，但等待数据就绪阶段由 select() 阻塞，复制数据阶段由 read() 阻塞。 </p>
<p><img src="https://ws1.sinaimg.cn/large/a67bf22fgy1fupj7yfa1jj20gx092t8q.jpg" alt=""></p>
<p>在BIO模型中，我们要实现非阻塞，由于不能知道什么时候可以从内核缓冲区中取数据又不想去浪费CPU资源，那么我们只能创建一个新的线程，然后使用新的线程去做接下来的事件然后等到可以取数据的时候，我们再去取。但是创建线程也是很消耗资源，而且当线程多了后切换线程也是很耗CPU资源的。所以在单线程下的IO多路复用的优点就凸显数来了，没有线程切换，只有拼命的读、写、选择事件，如果再利用好多核心进行IO那么效率还会有更大的提升</p>
<h5 id="Unix五种IO模型"><a href="#Unix五种IO模型" class="headerlink" title="Unix五种IO模型"></a>Unix五种IO模型</h5><ul>
<li>阻塞IO</li>
<li>非阻塞IO</li>
<li>IO复用（select、poll、epoll）</li>
<li>信号驱动IO</li>
<li>异步IO</li>
</ul>
<h5 id="Reactor和Proactor模式"><a href="#Reactor和Proactor模式" class="headerlink" title="Reactor和Proactor模式"></a>Reactor和Proactor模式</h5><p>其实java中Selector就是Reactor模式的实现，java中的AIO就是Proactor模式的实现；它们都要实现IO的多路复用，但是在事件分发者分发给事件处理者后（内核缓冲区数据准备好了）处理事件方式不一样；前者是同步的即在当前线程下处理IO任务（将内核缓冲区数据复制到用户空间），如果这个IO任务比较耗时就会比较浪费CPU资源；后者采用的方式的创建一个新的线程给事件处理者</p>
<h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><h5 id="java-nio基本概念"><a href="#java-nio基本概念" class="headerlink" title="java nio基本概念"></a>java nio基本概念</h5><p>nio就是new io，是相对于传统的io模型来说的；java nio是一种基于多路复用模型的同步非阻塞的io模型 。相对于传统就一个io流就需要一个线程来进行连接处理，nio的处理方式更加的节约资源，增加系统的吞吐量。</p>
<h5 id="java-nio的实现"><a href="#java-nio的实现" class="headerlink" title="java nio的实现"></a>java nio的实现</h5><p><img src="http://www.godpan.me/media/images/2017/11/java-nio.png" alt="java-nio"></p>
<p>上面就是java nio的一种基本模型；一个线程对应一个selector，一个selector可以绑定多个Channel，一个Channel对应着一个Buffer。当然这只是通常的做法，一个Channel也可以对应多个Selector，一个Channel对应着多个Buffer。</p>
<h6 id="selector"><a href="#selector" class="headerlink" title="selector"></a>selector</h6><p>selector就是java nio实现多路复用的关键；在传统io中，一个socket我们必须用一个线程去管理；而在这里我们在io流和线程中间抽象出一个selector出来，selector就可以去管理多个io流连接从而实现多路链接。</p>
<h6 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h6><p>通道是java nio的第二个主要创新。它们既不是一个扩展也不是一项增强,而是全新、极好的 Java I/O 示例,提供与 I/O 服务的直接连接。Channel 用于在字节缓冲区和位于通道另一侧的实体(通常是一个文件或套接字)之间有效地传输数据。通道是一种途径,借助该途径,可以用最小的总开销来访问操作系统本身的 I/O 服务。</p>
<h6 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h6><p>一个Buffer对象是固定数量的数据的容器。其作用是一个存储器,或者分段运输区,在这里数据可被存储并在之后用于检索。缓冲区的工作与通道紧密联系。通道是 I/O 传输发生时通过的入口,而缓冲区是这些数据传输的来源或目标。对于离开缓冲区的传输,您想传递出去的数据被置于一个缓冲区,被传送到通道。</p>
<p>下面是一段怎么将ByteBuffer里面的数据转换为utf-8数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getBufferString</span><span class="params">(ByteBuffer buffer)</span></span>&#123;</span><br><span class="line">    Charset charset = <span class="keyword">null</span>;</span><br><span class="line">    CharsetDecoder decoder = <span class="keyword">null</span>;</span><br><span class="line">    CharBuffer charBuffer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        charset = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line">        decoder = charset.newDecoder();</span><br><span class="line">        <span class="comment">// charBuffer = decoder.decode(buffer);//用这个的话，只能输出来一次结果，第二次显示为空</span></span><br><span class="line">        charBuffer = decoder.decode(buffer.asReadOnlyBuffer());</span><br><span class="line">        <span class="keyword">return</span> charBuffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="在java-nio中同步非阻塞的实现方式"><a href="#在java-nio中同步非阻塞的实现方式" class="headerlink" title="在java nio中同步非阻塞的实现方式"></a>在java nio中同步非阻塞的实现方式</h5><p>因为java nio是在传统io中包装过来的，所以它的本质还是同步的，而它的非阻塞就是通过channel是实现的。在代码中我们通常通过 循环selector.select()来得到连接或者待读取的通道，这里都是同步的；当得到一个连接准备写入或者读取数据的时候也就是channel的write和read方法会异步的进行，也就是在执行write方法时在还没有进行数据写进buffer之前就返回了，read同理在没有读数据到Buffer的时候就已经返回，而是通过开启一个新的线程来完成写入和读取操作。</p>
<h5 id="简单的nio服务器代码实现"><a href="#简单的nio服务器代码实现" class="headerlink" title="简单的nio服务器代码实现"></a>简单的nio服务器代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectableChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> javax.swing.text.html.HTMLDocument.Iterator;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Simple echo-back server which listens for incoming stream connections and</span></span><br><span class="line"><span class="comment">* echoes back whatever it reads. A single Selector object is used to listen to</span></span><br><span class="line"><span class="comment">* the server socket (to accept new connections) and all the active socket</span></span><br><span class="line"><span class="comment">* channels.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> zale (zalezone.cn)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSockets</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> PORT_NUMBER = <span class="number">1234</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SelectSockets().go(argv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = PORT_NUMBER;</span><br><span class="line">        <span class="keyword">if</span> (argv.length &gt; <span class="number">0</span>) </span><br><span class="line">        &#123; <span class="comment">// 覆盖默认的监听端口</span></span><br><span class="line">            port = Integer.parseInt(argv[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Listening on port "</span> + port);</span><br><span class="line">        ServerSocketChannel serverChannel = ServerSocketChannel.open();<span class="comment">// 打开一个未绑定的serversocketchannel</span></span><br><span class="line">        ServerSocket serverSocket = serverChannel.socket();<span class="comment">// 得到一个ServerSocket去和它绑定 </span></span><br><span class="line">        Selector selector = Selector.open();<span class="comment">// 创建一个Selector供下面使用</span></span><br><span class="line">        serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(port));<span class="comment">//设置server channel将会监听的端口</span></span><br><span class="line">        serverChannel.configureBlocking(<span class="keyword">false</span>);<span class="comment">//设置非阻塞模式</span></span><br><span class="line">        serverChannel.register(selector, SelectionKey.OP_ACCEPT);<span class="comment">//将ServerSocketChannel注册到Selector</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// This may block for a long time. Upon returning, the</span></span><br><span class="line">            <span class="comment">// selected set contains keys of the ready channels.</span></span><br><span class="line">            <span class="keyword">int</span> n = selector.select();</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// nothing to do</span></span><br><span class="line">            &#125;           </span><br><span class="line">            java.util.Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();<span class="comment">// Get an iterator over the set of selected keys</span></span><br><span class="line">            <span class="comment">//在被选择的set中遍历全部的key</span></span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) </span><br><span class="line">            &#123;</span><br><span class="line">                SelectionKey key = (SelectionKey) it.next();</span><br><span class="line">                <span class="comment">// 判断是否是一个连接到来</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) </span><br><span class="line">                &#123;</span><br><span class="line">                    ServerSocketChannel server =(ServerSocketChannel) key.channel();</span><br><span class="line">                    SocketChannel channel = server.accept();</span><br><span class="line">                    registerChannel(selector, channel,SelectionKey.OP_READ);<span class="comment">//注册读事件</span></span><br><span class="line">                    sayHello(channel);<span class="comment">//对连接进行处理</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断这个channel上是否有数据要读</span></span><br><span class="line">                <span class="keyword">if</span> (key.isReadable()) </span><br><span class="line">                &#123;</span><br><span class="line">                    readDataFromSocket(key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//从selected set中移除这个key，因为它已经被处理过了</span></span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Register the given channel with the given selector for the given</span></span><br><span class="line"><span class="comment">    * operations of interest</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerChannel</span><span class="params">(Selector selector,SelectableChannel channel, <span class="keyword">int</span> ops)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 可能会发生</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置通道为非阻塞</span></span><br><span class="line">        channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 将通道注册到选择器上</span></span><br><span class="line">        channel.register(selector, ops);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ----------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Use the same byte buffer for all channels. A single thread is</span></span><br><span class="line">    <span class="comment">// servicing all the channels, so no danger of concurrent acccess.</span></span><br><span class="line">    <span class="comment">//对所有的通道使用相同的缓冲区。单线程为所有的通道进行服务，所以并发访问没有风险</span></span><br><span class="line">    <span class="comment">// 就是说这里因为只有一个selector 也就是</span></span><br><span class="line">    <span class="keyword">private</span> ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line">    * Sample data handler method <span class="keyword">for</span> a channel with data ready to read.</span><br><span class="line">    * 对于一个准备读入数据的通道的简单的数据处理方法</span><br><span class="line">    * <span class="meta">@param</span> key</span><br><span class="line">    *</span><br><span class="line">    A SelectionKey object associated with a channel determined by</span><br><span class="line">    the selector to be ready <span class="keyword">for</span> reading. If the channel returns</span><br><span class="line">    an EOF condition, it is closed here, which automatically</span><br><span class="line">    invalidates the associated key. The selector will then</span><br><span class="line">    de-register the channel on the next select call.</span><br><span class="line"> </span><br><span class="line">    一个选择器决定了和通道关联的SelectionKey object是准备读状态。如果通道返回EOF，通道将被关闭。</span><br><span class="line">    并且会自动使相关的key失效，选择器然后会在下一次的select call时取消掉通道的注册</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">readDataFromSocket</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        buffer.clear(); <span class="comment">// 清空Buffer</span></span><br><span class="line">        <span class="comment">// Loop while data is available; channel is nonblocking</span></span><br><span class="line">        <span class="comment">//当可以读到数据时一直循环，通道为非阻塞</span></span><br><span class="line">        <span class="keyword">while</span> ((count = socketChannel.read(buffer)) &gt; <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            buffer.flip(); <span class="comment">// 将缓冲区置为可读</span></span><br><span class="line">            <span class="comment">// Send the data; don't assume it goes all at once</span></span><br><span class="line">            <span class="comment">//发送数据，不要期望能一次将数据发送完</span></span><br><span class="line">            <span class="keyword">while</span> (buffer.hasRemaining()) </span><br><span class="line">            &#123;</span><br><span class="line">                socketChannel.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// WARNING: the above loop is evil. Because</span></span><br><span class="line">            <span class="comment">// it's writing back to the same nonblocking</span></span><br><span class="line">            <span class="comment">// channel it read the data from, this code can</span></span><br><span class="line">            <span class="comment">// potentially spin in a busy loop. In real life</span></span><br><span class="line">            <span class="comment">// you'd do something more useful than this.</span></span><br><span class="line">            <span class="comment">//这里的循环是无意义的，具体按实际情况而定</span></span><br><span class="line">            buffer.clear(); <span class="comment">// Empty buffer</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) </span><br><span class="line">                    &#123;</span><br><span class="line">            <span class="comment">// Close channel on EOF, invalidates the key</span></span><br><span class="line">            <span class="comment">//读取结束后关闭通道，使key失效</span></span><br><span class="line">            socketChannel.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ----------------------------------------------------------</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Spew a greeting to the incoming client connection.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    The newly connected SocketChannel to say hello to.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(SocketChannel channel)</span> <span class="keyword">throws</span> Exception </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        buffer.clear();</span><br><span class="line">        buffer.put(<span class="string">"Hi there!\r\n"</span>.getBytes());</span><br><span class="line">        buffer.flip();</span><br><span class="line">        channel.write(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="线程池的通道实现代码"><a href="#线程池的通道实现代码" class="headerlink" title="线程池的通道实现代码"></a>线程池的通道实现代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Specialization of the SelectSockets class which uses a thread pool to service</span></span><br><span class="line"><span class="comment">* channels. The thread pool is an ad-hoc implementation quicky lashed togther</span></span><br><span class="line"><span class="comment">* in a few hours for demonstration purposes. It's definitely not production</span></span><br><span class="line"><span class="comment">* quality.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Ron Hitchens (ron@ronsoft.com)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSocketsThreadPool</span> <span class="keyword">extends</span> <span class="title">SelectSockets</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_THREADS = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> ThreadPool pool = <span class="keyword">new</span> ThreadPool(MAX_THREADS);</span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SelectSocketsThreadPool().go(argv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Sample data handler method for a channel with data ready to read. This</span></span><br><span class="line"><span class="comment">    * method is invoked from(被调用) the go( ) method in the parent class. This handler</span></span><br><span class="line"><span class="comment">    * delegates（委托） to a worker thread in a thread pool to service the channel,</span></span><br><span class="line"><span class="comment">    * then returns immediately.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    A SelectionKey object representing a channel determined by the</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    selector to be ready for reading. If the channel returns an</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    EOF condition, it is closed here, which automatically</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    invalidates the associated key. The selector will then</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    de-register the channel on the next select call.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">readDataFromSocket</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        WorkerThread worker = pool.getWorker();</span><br><span class="line">        <span class="keyword">if</span> (worker == <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// No threads available. Do nothing. The selection</span></span><br><span class="line">            <span class="comment">// loop will keep calling this method until a</span></span><br><span class="line">            <span class="comment">// thread becomes available. This design could</span></span><br><span class="line">            <span class="comment">// be improved.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Invoking this wakes up the worker thread, then returns</span></span><br><span class="line">        worker.serviceChannel(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ---------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * A very simple thread pool class. The pool size is set at construction</span></span><br><span class="line"><span class="comment">    * time and remains fixed. Threads are cycled through a FIFO idle queue.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        List idle = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        ThreadPool(<span class="keyword">int</span> poolSize) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Fill up the pool with worker threads</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolSize; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                WorkerThread thread = <span class="keyword">new</span> WorkerThread(<span class="keyword">this</span>);</span><br><span class="line">                <span class="comment">// Set thread name for debugging. Start it.</span></span><br><span class="line">                thread.setName(<span class="string">"Worker"</span> + (i + <span class="number">1</span>));</span><br><span class="line">                thread.start();</span><br><span class="line">                idle.add(thread);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Find an idle worker thread, if any. Could return null.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function">WorkerThread <span class="title">getWorker</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            WorkerThread worker = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (idle) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (idle.size() &gt; <span class="number">0</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    worker = (WorkerThread) idle.remove(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (worker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Called by the worker thread to return itself to the idle pool.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">returnWorker</span><span class="params">(WorkerThread worker)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (idle) </span><br><span class="line">            &#123;</span><br><span class="line">                idle.add(worker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * A worker thread class which can drain（排空） channels and echo-back（回显） the input.</span></span><br><span class="line"><span class="comment">    * Each instance is constructed with a reference（参考） to the owning thread pool</span></span><br><span class="line"><span class="comment">    * object. When started, the thread loops forever waiting to be awakened to</span></span><br><span class="line"><span class="comment">    * service the channel associated with a SelectionKey object. The worker is</span></span><br><span class="line"><span class="comment">    * tasked by calling its serviceChannel( ) method with a SelectionKey</span></span><br><span class="line"><span class="comment">    * object. The serviceChannel( ) method stores the key reference in the</span></span><br><span class="line"><span class="comment">    * thread object then calls notify( ) to wake it up. When the channel has</span></span><br><span class="line"><span class="comment">    * been drained, the worker thread returns itself to its parent pool.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">private</span> ThreadPool pool;</span><br><span class="line">        <span class="keyword">private</span> SelectionKey key;</span><br><span class="line">        WorkerThread(ThreadPool pool) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.pool = pool;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Loop forever waiting for work to do</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName() + <span class="string">" is ready"</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// Sleep and release object lock</span></span><br><span class="line">                    <span class="comment">//休眠并且释放掉对象锁</span></span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="comment">// Clear interrupt status</span></span><br><span class="line">                    <span class="keyword">this</span>.interrupted();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (key == <span class="keyword">null</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// just in case</span></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.getName() + <span class="string">" has been awakened"</span>);</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    drainChannel(key);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (Exception e) </span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Caught '"</span> + e + <span class="string">"' closing channel"</span>);</span><br><span class="line">                    <span class="comment">// Close channel and nudge selector</span></span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        key.channel().close();</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="keyword">catch</span> (IOException ex) </span><br><span class="line">                    &#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    key.selector().wakeup();</span><br><span class="line">                &#125;</span><br><span class="line">                key = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// Done. Ready for more. Return to pool</span></span><br><span class="line">                <span class="keyword">this</span>.pool.returnWorker(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Called to initiate a unit of work by this worker thread on the</span></span><br><span class="line"><span class="comment">        * provided SelectionKey object. This method is synchronized, as is the</span></span><br><span class="line"><span class="comment">        * run( ) method, so only one key can be serviced at a given time.</span></span><br><span class="line"><span class="comment">        * Before waking the worker thread, and before returning to the main</span></span><br><span class="line"><span class="comment">        * selection loop, this key's interest set is updated to remove OP_READ.</span></span><br><span class="line"><span class="comment">        * This will cause the selector to ignore read-readiness for this</span></span><br><span class="line"><span class="comment">        * channel while the worker thread is servicing it.</span></span><br><span class="line"><span class="comment">        * 通过一个被提供SelectionKey对象的工作线程来初始化一个工作集合，这个方法是同步的，所以</span></span><br><span class="line"><span class="comment">        * 里面的run方法只有一个key能被服务在同一个时间，在唤醒工作线程和返回到主循环之前，这个key的</span></span><br><span class="line"><span class="comment">        * 感兴趣的集合被更新来删除OP_READ，这将会引起工作线程在提供服务的时候选择器会忽略读就绪的通道</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">serviceChannel</span><span class="params">(SelectionKey key)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            key.interestOps(key.interestOps() &amp; (~SelectionKey.OP_READ));</span><br><span class="line">            <span class="keyword">this</span>.notify(); <span class="comment">// Awaken the thread</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The actual code which drains the channel associated with the given</span></span><br><span class="line"><span class="comment">        * key. This method assumes the key has been modified prior to</span></span><br><span class="line"><span class="comment">        * invocation to turn off selection interest in OP_READ. When this</span></span><br><span class="line"><span class="comment">        * method completes it re-enables OP_READ and calls wakeup( ) on the</span></span><br><span class="line"><span class="comment">        * selector so the selector will resume watching this channel.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">drainChannel</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">            <span class="keyword">int</span> count;</span><br><span class="line">            buffer.clear(); <span class="comment">// 清空buffer</span></span><br><span class="line">            <span class="comment">// Loop while data is available; channel is nonblocking</span></span><br><span class="line">            <span class="keyword">while</span> ((count = channel.read(buffer)) &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                buffer.flip(); <span class="comment">// make buffer readable</span></span><br><span class="line">                <span class="comment">// Send the data; may not go all at once</span></span><br><span class="line">                <span class="keyword">while</span> (buffer.hasRemaining()) </span><br><span class="line">                &#123;</span><br><span class="line">                    channel.write(buffer);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// WARNING: the above loop is evil.</span></span><br><span class="line">                <span class="comment">// See comments in superclass.</span></span><br><span class="line">                buffer.clear(); <span class="comment">// Empty buffer</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &lt; <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Close channel on EOF; invalidates the key</span></span><br><span class="line">                channel.close();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Resume interest in OP_READ</span></span><br><span class="line">            key.interestOps(key.interestOps() | SelectionKey.OP_READ);</span><br><span class="line">            <span class="comment">// Cycle the selector so this key is active again</span></span><br><span class="line">            key.selector().wakeup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="select、poll、epoll"><a href="#select、poll、epoll" class="headerlink" title="select、poll、epoll"></a>select、poll、epoll</h5><p>这三者都是IO多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。</p>
<p><strong>select</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</span><br></pre></td></tr></table></figure>
<p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。 </p>
<p><strong>poll</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int poll (struct pollfd *fds, unsigned int nfds, int timeout);</span><br></pre></td></tr></table></figure>
<p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct pollfd &#123;</span><br><span class="line">    int fd; /* file descriptor */</span><br><span class="line">    short events; /* requested events to watch */</span><br><span class="line">    short revents; /* returned events witnessed */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。 和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。 </p>
<p><strong>epoll</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size)；</span><br><span class="line"><span class="comment">//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，调用这个方法就会产生一个如下的结构体</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span>&#123;</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span>  <span class="title">rbr</span>;</span></span><br><span class="line">    <span class="comment">/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdlist</span>;</span></span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//我觉得rbr是在用户注册完需要监听的端口的所有事件后，系统在接受到一个请求后就会把此事件与这个红黑树rbr中的所有事件进行比较，如果有的话就会加入到rdlist，所以在用户不用遍历所有监听的端口而是只用遍历rdlist就可以得到所有可以读取的流</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span></span><br><span class="line"><span class="function"><span class="comment">//创建需要监听的事件</span></span></span><br><span class="line">epfd epoll的句柄id</span><br><span class="line">op 操作即是要对fd即端口删除、增加还是修改event，所有op对应 添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD</span><br><span class="line">fd 监听的端口对应的句柄</span><br><span class="line">event 进行op操作的所有事件</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">//从内核得到事件集合，返回需要处理的事件数目</span></span><br></pre></td></tr></table></figure>
<p>以上我们可以得出epoll相对于select和poll的优点：</p>
<ol>
<li>没有注册描述符的限制，也就是没有监听端口的限制，也不会因为监听端口的增加而性能降低</li>
<li>不用去遍历所有流得到能读或者写的流，epoll已经把哪个流产生了怎样的IO事件通知了我们，我们直接取出来即可</li>
</ol>
<h4 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h4><p>在我看来一下的两种方式其实都是通过一种方式来进行异步的：先是通过多路复用也就是Nio来实现非阻塞，然后再通过创建线程做其它事情的方式避免等待从内核缓冲区向用户空间复制数据</p>
<p>所以它们有一个共同点就是要先在用户空间创建buffer</p>
<p><strong>Future方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">    Path path =                                               Paths.get(<span class="string">"/data/code/github/java_practice/src/main/resources/1log4j.properties"</span>);</span><br><span class="line">    AsynchronousFileChannel channel = AsynchronousFileChannel.open(path);</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    Future future = channel.read(buffer,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//        while (!future.isDone())&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println("I'm idle");</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//我们可以在这里做其它事情</span></span><br><span class="line">    Integer readNumber = future.get();</span><br><span class="line"></span><br><span class="line">    buffer.flip();</span><br><span class="line">    CharBuffer charBuffer = CharBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    CharsetDecoder decoder = Charset.defaultCharset().newDecoder();</span><br><span class="line">    decoder.decode(buffer,charBuffer,<span class="keyword">false</span>);</span><br><span class="line">    charBuffer.flip();</span><br><span class="line">    String data = <span class="keyword">new</span> String(charBuffer.array(),<span class="number">0</span>, charBuffer.limit());</span><br><span class="line">    System.out.println(<span class="string">"read number:"</span> + readNumber);</span><br><span class="line">    System.out.println(data);</span><br></pre></td></tr></table></figure>
<p>因为Future的本质就是直接返回而创建新的线程运算得到结果，运算结束后自己去取结果</p>
<p><strong>回调方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">"/data/code/github/java_practice/src/main/resources/1log4j.properties"</span>);</span><br><span class="line">AsynchronousFileChannel channel = AsynchronousFileChannel.open(path);</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">channel.read(buffer, <span class="number">0</span>, buffer, <span class="keyword">new</span> CompletionHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" read success!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"read error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">" sleep"</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建新的线程从内核取数据，所以completed方法也是在新线程上完成的</p>
<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p>Linux io模式、select、poll、epoll</p>
<p><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">https://segmentfault.com/a/1190000003063859</a></p>
<p><a href="https://blog.csdn.net/tianjing0805/article/details/76021440" target="_blank" rel="noopener">https://blog.csdn.net/tianjing0805/article/details/76021440</a></p>
<p>Aio</p>
<p><a href="https://juejin.im/entry/583ec2e3128fe1006bfa6c83" target="_blank" rel="noopener">https://juejin.im/entry/583ec2e3128fe1006bfa6c83</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/MayYJ/hexo/2018/03/13/java/transient关键字/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="May">
      <meta itemprop="description" content="既然选择了远方，便只顾风雨兼程。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="May's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/13/java/transient关键字/" itemprop="url">
                  transient关键字
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Geplaatst op</span>
              

              
                
              

              <time title="Post aangemaakt: 2018-03-13 22:55:25" itemprop="dateCreated datePublished" datetime="2018-03-13T22:55:25+08:00">2018-03-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Post aangepast: 2018-05-26 17:27:55" itemprop="dateModified" datetime="2018-05-26T17:27:55+08:00">2018-05-26</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/MayYJ/hexo/2018/03/13/java/深克隆和浅克隆/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="May">
      <meta itemprop="description" content="既然选择了远方，便只顾风雨兼程。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="May's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/13/java/深克隆和浅克隆/" itemprop="url">
                  深克隆和浅克隆
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Geplaatst op</span>
              

              
                
              

              <time title="Post aangemaakt: 2018-03-13 22:43:44" itemprop="dateCreated datePublished" datetime="2018-03-13T22:43:44+08:00">2018-03-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Post aangepast: 2018-05-26 17:27:55" itemprop="dateModified" datetime="2018-05-26T17:27:55+08:00">2018-05-26</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/MayYJ/hexo/2018/03/13/java/源码解析/ArrayList源码解析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="May">
      <meta itemprop="description" content="既然选择了远方，便只顾风雨兼程。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="May's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/13/java/源码解析/ArrayList源码解析/" itemprop="url">
                  ArrayList源码解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Geplaatst op</span>
              

              
                
              

              <time title="Post aangemaakt: 2018-03-13 22:21:23" itemprop="dateCreated datePublished" datetime="2018-03-13T22:21:23+08:00">2018-03-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Post aangepast: 2018-05-26 17:27:55" itemprop="dateModified" datetime="2018-05-26T17:27:55+08:00">2018-05-26</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>####Arrays.copyof</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T, U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">        T[] copy = newType == Object[].class ? new Object[newLength] : (Object[])Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">        System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength));</span><br><span class="line">        return copy;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>函数解释：返回一个元素original数组一样的但是引用不一样的数组。</p>
<p>####System.arraycopy</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数解释：从指定的源数组复制数组，从指定位置，到目标数组的制定位置。源数组为src，目标数组为dest，复制的组件数量为length，从源数组复制的位置从下标srcPos到srcPos+length-1(源数组要复制的结尾的下标)，被复制到dest数组从下标destPos到destPos+length-1(目标数组要复制的结尾的下标)的位置。</p>
<p>####变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>; <span class="comment">//默认的数组容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = <span class="keyword">new</span> Object[<span class="number">0</span>]; <span class="comment">//临时实例化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">//缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;<span class="comment">//数组大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = <span class="number">2147483639</span>; <span class="comment">//MAX_ARRAY_SIZE=Integer.MAX_VALNE-8;是因为虚拟机在数组数组类型数据中保留head word字段，其会占用空间。</span></span><br></pre></td></tr></table></figure>
<p>####构造器</p>
<ol>
<li><p>无参构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList() &#123;</span><br><span class="line">   this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造时是将空数组赋值给elementData ，但是在随后的第一个add元素的时候，会先新创建一个容量为10的初始数组。</p>
</li>
<li><p>指定容量构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span> + initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>集合构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    this.elementData = c.toArray();</span><br><span class="line">    if ((this.size = this.elementData.length) != 0) &#123;</span><br><span class="line">        if (this.elementData.getClass() != Object[].class) &#123;</span><br><span class="line">            this.elementData = Arrays.copyOf(this.elementData, this.size, Object[].class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>####Method</p>
<h5 id="add"><a href="#add" class="headerlink" title="add"></a>add</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void add(E e, Object[] elementData, int s) &#123;</span><br><span class="line">    if (s == elementData.length) &#123;</span><br><span class="line">        elementData = this.grow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elementData[s] = e;</span><br><span class="line">    this.size = s + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一次添加元素的时候都会检查缓存数组的长度是否不够，不够就会加1</p>
<h5 id="grow"><a href="#grow" class="headerlink" title="grow"></a>grow</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private Object[] grow() &#123;</span><br><span class="line">    return this.grow(this.size + 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  private Object[] grow(int minCapacity) &#123;</span><br><span class="line">    return this.elementData =   Arrays.copyOf(this.elementData,this.newCapacity(minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="newCapacity"><a href="#newCapacity" class="headerlink" title="newCapacity"></a>newCapacity</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = <span class="keyword">this</span>.elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(<span class="number">10</span>, minCapacity);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> minCapacity;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> newCapacity - <span class="number">2147483639</span> &lt;= <span class="number">0</span> ? newCapacity : hugeCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果指定容量大于初始容量的1.5倍，且容量为空的话就初始化容量为10，不然就是指定容量的大小；所以这里当一个空的ArrayList添加一个元素后容量都会变为10.</p>
<h5 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">    Objects.checkIndex(index, this.size);</span><br><span class="line">    ++this.modCount;</span><br><span class="line">    E oldValue = this.elementData(index);</span><br><span class="line">    int numMoved = this.size - index - 1;</span><br><span class="line">    if (numMoved &gt; 0) &#123;</span><br><span class="line">        System.arraycopy(this.elementData, index + 1, this.elementData, index, numMoved);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.elementData[--this.size] = null;</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把从要移除元素的下标位置开始每个元素向前移动一个位置，然后另最后一个元素为null；</p>
<h5 id="addAll"><a href="#addAll" class="headerlink" title="addAll"></a>addAll</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    this.rangeCheckForAdd(index);</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    ++this.modCount;</span><br><span class="line">    int numNew = a.length;</span><br><span class="line">    if (numNew == 0) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Object[] elementData = this.elementData;</span><br><span class="line">        int var10001 = this.elementData.length;</span><br><span class="line">        int s = this.size;</span><br><span class="line">        if (numNew &gt; var10001 - this.size) &#123;</span><br><span class="line">            elementData = this.grow(s + numNew);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int numMoved = s - index;</span><br><span class="line">        if (numMoved &gt; 0) &#123;</span><br><span class="line">            System.arraycopy(elementData, index, elementData, index + numNew, numMoved);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.arraycopy(a, 0, elementData, index, numNew);</span><br><span class="line">        this.size = s + numNew;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先扩大数组容量，然后从指定位置开始把所有元素向后面移动要添加元素数量的位置，然后再将要添加元素的从指定位置开始插入。</p>
<h5 id="removeRange"><a href="#removeRange" class="headerlink" title="removeRange"></a>removeRange</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected void removeRange(int fromIndex, int toIndex) &#123;</span><br><span class="line">    if (fromIndex &gt; toIndex) &#123;</span><br><span class="line">        throw new IndexOutOfBoundsException(outOfBoundsMsg(fromIndex, toIndex));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ++this.modCount;</span><br><span class="line">        this.shiftTailOverGap(this.elementData, fromIndex, toIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从toIndex+1以后的所有元素移动到fromIndex的位置以后，然后再另length-1-（toIndex-fromIndex）位置后的所有元素为null</p>
<h4 id="一些内部类"><a href="#一些内部类" class="headerlink" title="一些内部类"></a>一些内部类</h4><h5 id="ArrayListSpliterator"><a href="#ArrayListSpliterator" class="headerlink" title="ArrayListSpliterator"></a>ArrayListSpliterator</h5><p>java8 并行迭代 Spliterator接口</p>
<p>Spliterator 是Java8 引入的新接口，顾名思义，<strong>Spliterator可以理解为Iterator的Split版本，对于Java的流API，进行并行分割迭代计算，充分利用多核CPU的优势，并行计算具有极大的辅助作用</strong>。在使用Iterator的时候，我们一般都是单线程地去顺序遍历集合的元素，但是使用Spliterator可以将集合元素分割成多份，使用多个线程 同时进行迭代，大大地提高了执行效率。</p>
<h5 id="SubList"><a href="#SubList" class="headerlink" title="SubList"></a>SubList</h5><p>相当于ArrayList的一个子视图，所以对它的操作也会反应到ArrayList上，它的工作原理就是依赖于下面三个变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;E&gt; root; <span class="comment">// 从root里面获得子list</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset; <span class="comment">//SubList的开始，root截断的起点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;<span class="comment">//subList的大小</span></span><br></pre></td></tr></table></figure>
<h5 id="Itr"><a href="#Itr" class="headerlink" title="Itr"></a>Itr</h5><p>ArrayList自定义实现的容器，实现了<strong>fail-fast机制（在遍历过程中如果modCount与expectedModCount不相等，则抛出ConcurrentModificationException异常）</strong></p>
<h5 id="ListItr"><a href="#ListItr" class="headerlink" title="ListItr"></a>ListItr</h5><p>继承自ArrayList<e>.Itr，扩展了ListIterator<e>的方法，能够在遍历过程中进行更多的操作。</e></e></p>
<h4 id="三种元素访问"><a href="#三种元素访问" class="headerlink" title="三种元素访问"></a>三种元素访问</h4><ol>
<li>随机访问</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String value = null;</span><br><span class="line">int size = list.size();</span><br><span class="line">for (int i=0; i&lt;size; i++) &#123;</span><br><span class="line">    value = (String )list.get(i);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法是直接在缓冲数组上的通过索引访问的，<strong>速度最快</strong></p>
<ol start="2">
<li>foreach访问</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String value = null;</span><br><span class="line">for(String a : list)&#123;</span><br><span class="line">    value = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>foreach访问也比随机访问要慢，但是要快于迭代器的方式（foreach是一种<strong>语法糖</strong>，在编译期间需要进行<strong>语法解析</strong>，插入额外的辅助访问的代码，会有一定的消耗）</p>
<ol start="3">
<li>迭代器访问</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String value = null;</span><br><span class="line">Iterator iter = list.iterator();</span><br><span class="line">while (iter.hasNext()) &#123;</span><br><span class="line">    value = (String )iter.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>速度最慢</strong>，由于要保存迭代器的状态，所以性能受到损耗</p>
<h4 id="一些需要注意的点"><a href="#一些需要注意的点" class="headerlink" title="一些需要注意的点"></a>一些需要注意的点</h4><ol>
<li>底层通过System.arraycopy将原来ArrayList的<strong>缓冲数组elementData拷贝给新的ArrayList的缓冲数组</strong>，这里是一个深克隆，操作新的数组并不会改变原来的数组的状态。</li>
<li><strong>每一次影响集合结构的修改（包括增加、删除、扩容、移动元素位置，不包括修改set）</strong>ArrayList的时候都要使得<strong>modCount自增</strong>，确保感知在使用<strong>迭代器</strong>和<strong>进行序列化过程中</strong>是否发生并发修改ArrayList的情况</li>
<li>在子列表上的操作（如add、remove等）都会反映到原来的ArrayList上面（共用elementData），即子列表只是提供一种在原列表上的一种视图。</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/MayYJ/hexo/2018/03/12/java/java位运算符/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="May">
      <meta itemprop="description" content="既然选择了远方，便只顾风雨兼程。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="May's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/12/java/java位运算符/" itemprop="url">
                  java位运算符
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Geplaatst op</span>
              

              
                
              

              <time title="Post aangemaakt: 2018-03-12 19:28:05" itemprop="dateCreated datePublished" datetime="2018-03-12T19:28:05+08:00">2018-03-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Post aangepast: 2018-05-26 17:27:55" itemprop="dateModified" datetime="2018-05-26T17:27:55+08:00">2018-05-26</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>binary 二进制 octal 八进制 decimal 十进制 hexaddecimal 十六进制</p>
<p>a = D(60) = B(001111100)</p>
<p>b = D(13) = B(00001101)</p>
<hr>
<h5 id="按位右移运算符-gt-gt"><a href="#按位右移运算符-gt-gt" class="headerlink" title="按位右移运算符(&gt;&gt;)"></a>按位右移运算符(&gt;&gt;)</h5><p>左操作数按位右移右操作数指定的位数</p>
<p>a&gt;&gt;2 = D(15) =  B(1111)</p>
<p>对于十进制来说就是　ａ= a / 2^2</p>
<hr>
<h5 id="按位左移运算符-lt-lt"><a href="#按位左移运算符-lt-lt" class="headerlink" title="按位左移运算符(&lt;&lt;)"></a>按位左移运算符(&lt;&lt;)</h5><p>左操作数按位左移右操作数指定的位数</p>
<p>a&lt;&lt;2 = D(240) = H(11110000)</p>
<p>对于十进制来说就是　ａ = a* 2^2</p>
<hr>
<h5 id="按位右移补零运算符-gt-gt-gt"><a href="#按位右移补零运算符-gt-gt-gt" class="headerlink" title="按位右移补零运算符(&gt;&gt;&gt;)"></a>按位右移补零运算符(&gt;&gt;&gt;)</h5><p>a&gt;&gt;&gt;2 =     D(15) = B(00001111)</p>
<hr>
<h5 id="与运算符-amp"><a href="#与运算符-amp" class="headerlink" title="与运算符(&amp;)"></a>与运算符(&amp;)</h5><p>如果相对应位都是1，则结果为1，否则为0</p>
<p>a&amp;b = D(12) = B(00001100)</p>
<hr>
<h5 id="或运算符"><a href="#或运算符" class="headerlink" title="或运算符(|)"></a>或运算符(|)</h5><p>如果相对应位都是0，则结果为0，否则为1</p>
<p>(a|b) = D(61) = B(00111101)</p>
<hr>
<p>#####　^运算符</p>
<p>如果相对应位值相同，则结果为0，否则为1</p>
<p>(a ^ b) = D(49) = B(00110001)</p>
<hr>
<h5 id="运算符"><a href="#运算符" class="headerlink" title="~运算符"></a>~运算符</h5><p>按位补运算符翻转操作数的每一位，即0变成1，1变成0。</p>
<p>~a = D(-61) = B(11000011)</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/MayYJ/hexo/2018/03/12/java/源码解析/String源码解析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="May">
      <meta itemprop="description" content="既然选择了远方，便只顾风雨兼程。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="May's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/12/java/源码解析/String源码解析/" itemprop="url">
                  String源码解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Geplaatst op</span>
              

              
                
              

              <time title="Post aangemaakt: 2018-03-12 19:19:44" itemprop="dateCreated datePublished" datetime="2018-03-12T19:19:44+08:00">2018-03-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Post aangepast: 2018-08-02 11:02:23" itemprop="dateModified" datetime="2018-08-02T11:02:23+08:00">2018-08-02</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>####变化</p>
<p>在JDK 8之前，String的源码实现都是通过使用char数组接收字符串，但是每个char字符是由两个字符组成，因为java内部使用UTF-16实现；如果一个字符串含有英文字符，那么这些英文字符的前 8 比特都将为 0，因为一个ASCII字符都能被单个字节来表示。然而我们在使用字符串的时候只需8bit的情况占大多数。由于这种情况jvm堆空间通常很大一部分被字符串占据。</p>
<p>在java1.6时候引入了一个新的虚拟机参数 UseCompressedStrings；字符串将以byte数组的形式存储，代替原来的char。然而在JDK 7中被移除，主要原因在于它将带来一些如法预料的性能问题。</p>
<h4 id="JDK-9中String对象的实现"><a href="#JDK-9中String对象的实现" class="headerlink" title="JDK 9中String对象的实现"></a>JDK 9中String对象的实现</h4><p>#####实现方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final byte[] value;</span><br></pre></td></tr></table></figure>
<p>用于存储String的字节编码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private final byte coder;</span><br><span class="line">static	 final boolean COMPACT_STRINGS = true;</span><br><span class="line">static final byte LATIN1 = 0;</span><br><span class="line">static final byte UTF16 = 1;</span><br></pre></td></tr></table></figure>
<p>这些是JDK 9用于解决字符串占用内存空间大的方案的变量</p>
<p>每个String对象都拥有一个coder变量，它有两个值:0或者1,分别对应LATIN1和UTF16；当coder=0时表示这个String对象是用LATIN1字符集进行编码，当coder=1时表示String对象是用UTF16进行编码。    </p>
<p>我们可以根据构造函数作为切入点进行探究</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public String(char[] value) &#123;</span><br><span class="line">    this((char[])value, 0, value.length, (Void)null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String(char[] value, int off, int len, Void sig) &#123;</span><br><span class="line">    if (len == 0) &#123;</span><br><span class="line">        this.value = &quot;&quot;.value;</span><br><span class="line">        this.coder = &quot;&quot;.coder;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (COMPACT_STRINGS) &#123;</span><br><span class="line">            byte[] val = StringUTF16.compress(value, off, len);</span><br><span class="line">            if (val != null) &#123;</span><br><span class="line">                this.value = val;</span><br><span class="line">                this.coder = 0;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.coder = 1;</span><br><span class="line">        this.value = StringUTF16.toBytes(value, off, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  从第二个构造函数我们可以很清楚的看到实现方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (COMPACT_STRINGS) &#123;</span><br><span class="line">      <span class="keyword">byte</span>[] val = StringUTF16.compress(value, off, len);</span><br><span class="line">      <span class="keyword">if</span> (val != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.value = val;</span><br><span class="line">          <span class="keyword">this</span>.coder = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">this</span>.coder = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">this</span>.value = StringUTF16.toBytes(value, off, len);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//StringUTF16的方法    </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] compress(<span class="keyword">char</span>[] val, <span class="keyword">int</span> off, <span class="keyword">int</span> len) &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] ret = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">    <span class="keyword">return</span> compress((<span class="keyword">char</span>[])val, off, ret, <span class="number">0</span>, len) == len ? ret : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">//StringUTF16的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compress</span><span class="params">(<span class="keyword">char</span>[] src, <span class="keyword">int</span> srcOff, <span class="keyword">byte</span>[] dst, </span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> dstOff, <span class="keyword">int</span> len）&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c = src[srcOff];</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">255</span>) &#123;</span><br><span class="line">            len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dst[dstOff] = (<span class="keyword">byte</span>)c;</span><br><span class="line">        ++srcOff;</span><br><span class="line">        ++dstOff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先根据String的类变量COMPACT_STRINGS 默认为true判断是否对String对象进行压缩；根据compress()方法我们能够看出来 压缩是根据字符串是不是全部能够根据ASCII码表找对应的编码，如果有一个字符不符合，那么就会返回0，从而不进行压缩，而是直接采用UTF16进行编码。</p>
<hr>
<h5 id="内置的比较器"><a href="#内置的比较器" class="headerlink" title="内置的比较器"></a>内置的比较器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER = new String.CaseInsensitiveComparator();</span><br></pre></td></tr></table></figure>
<p>这个是String内部默认的排序方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private static class CaseInsensitiveComparator implements Comparator&lt;String&gt;, Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 8575799808933029326L;</span><br><span class="line"></span><br><span class="line">    private CaseInsensitiveComparator() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int compare(String s1, String s2) &#123;</span><br><span class="line">        byte[] v1 = s1.value;</span><br><span class="line">        byte[] v2 = s2.value;</span><br><span class="line">        if (s1.coder() == s2.coder()) &#123;</span><br><span class="line">            return s1.isLatin1() ? StringLatin1.compareToCI(v1, v2) : StringUTF16.compareToCI(v1, v2);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return s1.isLatin1() ? StringLatin1.compareToCI_UTF16(v1, v2) : StringUTF16.compareToCI_Latin1(v1, v2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Object readResolve() &#123;</span><br><span class="line">        return String.CASE_INSENSITIVE_ORDER;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码也可以很容易看出来就是从第一个字符开始挨着挨着的比较，如果有一个字符不一样，那么就会直接比较这两个字符的大小，从而得出两个字符串的大小。</p>
<h5 id="从源码可以学到的东西"><a href="#从源码可以学到的东西" class="headerlink" title="从源码可以学到的东西"></a>从源码可以学到的东西</h5><ol>
<li><p>检查方法参数是否正确</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span>[] value, <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(value, offset, count, rangeCheck(value, offset, count));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> String(<span class="keyword">char</span>[] value, <span class="keyword">int</span> off, <span class="keyword">int</span> len, Void sig) &#123;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">        <span class="keyword">this</span>.coder = <span class="string">""</span>.coder;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (COMPACT_STRINGS) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] val = StringUTF16.compress(value, off, len);</span><br><span class="line">            <span class="keyword">if</span> (val != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.value = val;</span><br><span class="line">                <span class="keyword">this</span>.coder = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.coder = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = StringUTF16.toBytes(value, off, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以用Void类型作为参数，接受如果运行正确的方法返回值为void的方法。</p>
<ol start="2">
<li><p>String类中存在的同步</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public boolean contentEquals(CharSequence cs) &#123;</span><br><span class="line">    if (cs instanceof AbstractStringBuilder) &#123;</span><br><span class="line">        if (cs instanceof StringBuffer) &#123;</span><br><span class="line">            synchronized(cs) &#123;</span><br><span class="line">                return this.nonSyncContentEquals((AbstractStringBuilder)cs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return this.nonSyncContentEquals((AbstractStringBuilder)cs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (cs instanceof String) &#123;</span><br><span class="line">        return this.equals(cs);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int n = cs.length();</span><br><span class="line">        if (n != this.length()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            byte[] val = this.value;</span><br><span class="line">            if (this.isLatin1()) &#123;</span><br><span class="line">                for(int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">                    if ((val[i] &amp; 255) != cs.charAt(i)) &#123;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (!StringUTF16.contentEquals(val, cs, n)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean nonSyncContentEquals(AbstractStringBuilder sb) &#123;</span><br><span class="line">    int len = this.length();</span><br><span class="line">    if (len != sb.length()) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        byte[] v1 = this.value;</span><br><span class="line">        byte[] v2 = sb.getValue();</span><br><span class="line">        if (this.coder() == sb.getCoder()) &#123;</span><br><span class="line">            int n = v1.length;</span><br><span class="line"></span><br><span class="line">            for(int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">                if (v1[i] != v2[i]) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return !this.isLatin1() ? false : StringUTF16.contentEquals(v1, v2, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在多线程中可能存在在比较的过程中，被比较的字符串被其它县城关改变，造成运行出错。</p>
</li>
</ol>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/MayYJ/hexo/2018/03/12/java/面向实习的java后台学习知识点（待完善）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="May">
      <meta itemprop="description" content="既然选择了远方，便只顾风雨兼程。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="May's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/12/java/面向实习的java后台学习知识点（待完善）/" itemprop="url">
                  面向实习的java后台学习知识点（待完善）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Geplaatst op</span>
              

              
                
              

              <time title="Post aangemaakt: 2018-03-12 14:59:50" itemprop="dateCreated datePublished" datetime="2018-03-12T14:59:50+08:00">2018-03-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Post aangepast: 2018-05-26 17:27:55" itemprop="dateModified" datetime="2018-05-26T17:27:55+08:00">2018-05-26</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h4><ul>
<li><p>集合框架 hashmap、linkedlist、arraylist</p>
</li>
<li><p>线程安全 vector、concurrenthash、hashtable</p>
</li>
<li><p>线程安全 </p>
<ul>
<li>关键字： syncronized、 violate 、reenterlock</li>
</ul>
</li>
<li><p>jvm锁优化 自旋锁…..</p>
</li>
<li><p>String</p>
<ul>
<li>常量池：运行时常量池、静态常量池</li>
<li>final —-&gt; 并发</li>
<li>StringBUffer、StringBuilder</li>
</ul>
</li>
<li><p>线程</p>
<ul>
<li>很杂（多线程面经）</li>
<li>线程池<ul>
<li>有哪些</li>
<li>阻塞队列</li>
<li>拒绝策略</li>
</ul>
</li>
</ul>
</li>
<li><p>io</p>
<ul>
<li><p>BIO</p>
</li>
<li><p>NIO</p>
<p><strong>nio在RPC框架中的作用</strong></p>
</li>
</ul>
</li>
<li><p>object</p>
<ul>
<li>toString</li>
<li>hushcode</li>
<li>equals</li>
<li>深克隆和浅克隆</li>
<li>wait 和sleep()</li>
<li>notify 和notifyall</li>
</ul>
</li>
</ul>
<h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><ul>
<li>内存区域</li>
<li>内存分配</li>
<li>内存回收 (GC 和 GC算法)</li>
<li>class文件结构</li>
<li>内存模型(线程)<ul>
<li>线程实现</li>
<li>线程优化</li>
<li>类加载器</li>
</ul>
</li>
</ul>
<h4 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h4><ul>
<li><strong>IOC</strong>(很重要的点，需要了解底层)</li>
<li><strong>AOP</strong>（很重要的点，需要了解底层）</li>
<li>事务</li>
</ul>
<h4 id="mybaties"><a href="#mybaties" class="headerlink" title="mybaties"></a>mybaties</h4><ul>
<li>怎么实现事务</li>
</ul>
<h4 id="spring-mvc"><a href="#spring-mvc" class="headerlink" title="spring mvc"></a>spring mvc</h4><ul>
<li><p>SpringBeanFactory</p>
</li>
<li><p>spirngMVC处理流程</p>
</li>
<li><p>springmvc容器初始化</p>
<p>mysql</p>
</li>
</ul>
<ul>
<li>事务（四个特性、隔离级别、读问题）</li>
<li>并发处理(悲观锁、乐观锁)</li>
<li>索引(betry，hash、全文、空间)</li>
<li>优化(sql优化、分库分表(mycat) )</li>
</ul>
<h4 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h4><ul>
<li>http：分层、https 数字含义</li>
<li>tcp：三次握手、四次挥手</li>
<li>udp</li>
<li>cookie、session</li>
</ul>
<h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><ul>
<li>调度算法</li>
<li>cpu</li>
<li>大文件的排序</li>
</ul>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul>
<li>数组(内存形式)—&gt;</li>
</ul>
<p>链表(栈(递归调用)、队列)—&gt;树(二叉树、完全二叉树、排序二叉树、平衡二叉树(B树)、遍历过程（中序、）)—&gt;图(因为现在还没有学习数据结构，学习过后再来总结这里的大的知识点)</p>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ul>
<li>查找</li>
<li>排序</li>
</ul>
<ul>
<li>动态规划(贪婪算法)</li>
</ul>
<h4 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h4><ul>
<li>RPC(三宗罪、nio)</li>
<li>负载均衡(无状态服务)</li>
<li>注册中心(nio、路由算法、缓存(雪崩、扩展、内存/jvm 缓存))</li>
<li>数据库缓存集群（读写分离、分库分表、高可用高扩展）</li>
</ul>
<h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><p>了解其基本实现</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/MayYJ/hexo/2018/03/09/linux/linux上安装和部署/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="May">
      <meta itemprop="description" content="既然选择了远方，便只顾风雨兼程。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="May's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/09/linux/linux上安装和部署/" itemprop="url">
                  linux上安装和部署redis
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Geplaatst op</span>
              

              
                
              

              <time title="Post aangemaakt: 2018-03-09 19:37:40" itemprop="dateCreated datePublished" datetime="2018-03-09T19:37:40+08:00">2018-03-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Post aangepast: 2018-08-27 10:27:31" itemprop="dateModified" datetime="2018-08-27T10:27:31+08:00">2018-08-27</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="关于linux下软件通过源码的安装"><a href="#关于linux下软件通过源码的安装" class="headerlink" title="关于linux下软件通过源码的安装"></a>关于linux下软件通过源码的安装</h4><ul>
<li>主要是以下四个步骤：<ol>
<li>./configure  这个步骤主要是为了建立MakeFile文档</li>
<li>make clean  主要是为了清除可能已经产生了修改却编译了的目标文件</li>
<li>make 使用make就是要将原始码编译成为可以被执行的可执行档，而这个可执行档会放置在目前所在的目录之下，尚未被安装到预定安装的目录中 </li>
<li>make install 通常这就是最后的安装步骤了，make会依据Makefile这个档案里面关于install的项目，将上一个步骤所编译完成的资料给他安装到预定的目录中 </li>
</ol>
</li>
</ul>
<h4 id="redis的安装和部署"><a href="#redis的安装和部署" class="headerlink" title="redis的安装和部署"></a>redis的安装和部署</h4><p>1.基础知识<br> redis是用C语言开发的一个开源的高性能键值对（key-value）数据库。它通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止redis支持的键值数据类型如下<br>字符串、列表（lists）、集合（sets）、有序集合（sorts sets）、哈希表（hashs）<br>2.redis的应用场景<br> 缓存（数据查询、短连接、新闻内容、商品内容等等）。（最多使用）<br> 分布式集群架构中的session分离。<br> 聊天室的在线好友列表。<br> 任务队列。（秒杀、抢购、12306等等）<br> 应用排行榜。<br> 网站访问统计。<br>  数据过期处理（可以精确到毫秒）<br>3.安装redis<br> 下面介绍在Linux环境下，Redis的安装与部署，使用redis-3.0稳定版,因为redis从3.0开始增加了集群功能。在后面我也会分享redis集群。<br> 1.可以通过官网下载  地址：<a href="https://link.jianshu.com?t=http://download.redis.io/releases/redis-3.0.0.tar.gz" target="_blank" rel="noopener">http://download.redis.io/releases/redis-3.0.0.tar.gz</a><br> 2.使用linux wget命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-3.0.0.tar.gz</span><br></pre></td></tr></table></figure>
<p>将redis-3.0.0.tar.gz拷贝到/usr/local下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp redis-3.0.0.rar.gz /usr/local</span><br></pre></td></tr></table></figure>
<p>解压源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf redis-3.0.0.tar.gz</span><br></pre></td></tr></table></figure>
<p>进入解压后的目录进行编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/redis-3.0.0</span><br></pre></td></tr></table></figure>
<p>安装到指定目录  如 /usr/local/redis</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make PREFIX=/usr/local/redis install</span><br></pre></td></tr></table></figure>
<p>redis.conf是redis的配置文件，redis.conf在redis源码目录。<br>拷贝配置文件到安装目录下<br>进入源码目录，里面有一份配置文件 redis.conf，然后将其拷贝到安装路径下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/redis</span><br><span class="line">mkdir conf</span><br><span class="line">cp /usr/local/redis-3.0.0/redis.conf  /usr/local/redis/bin</span><br></pre></td></tr></table></figure>
<p>进入安装目录bin下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/redis/bin</span><br></pre></td></tr></table></figure>
<p>此时我们看到的目录结构是这样的</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5145552-5e2339176d6a2d63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>redis-benchmark   redis性能测试工具<br>redis-check-aof     AOF文件修复工具<br>redis-check-rdb     RDB文件修复工具<br>redis-cli      redis命令行客户端<br>redis.conf   redis配置文件<br>redis-sentinal   redis集群管理工具<br>redis-server  redis服务进程</p>
<p>4.启动redis<br> 1.前端模式启动<br>直接运行bin/redis-server将以前端模式启动，前端模式启动的缺点是ssh命令窗口关闭则redis-server程序结束，不推荐使用此方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-server</span><br></pre></td></tr></table></figure>
<p>如图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5145552-a3bbd113c8131572.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p> 2.后端模式启动<br>修改redis.conf配置文件， daemonize yes 以后端模式启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/redis/bin/redis.conf</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/5145552-6e99ad064ae73055.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>执行如下命令启动redis：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/redis</span><br><span class="line">./bin/redis-server ./redis.conf</span><br></pre></td></tr></table></figure>
<p>连接redis</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/redis/bin/redis-cli</span><br></pre></td></tr></table></figure>
<p>5.关闭redis<br>强行终止redis进程可能会导致redis持久化数据丢失。正确停止Redis的方式应该是向Redis发送SHUTDOWN命令，命令为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/redis</span><br><span class="line">./bin/redis-cli shutdown</span><br></pre></td></tr></table></figure>
<p>强行终止redis</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkill redis-server</span><br></pre></td></tr></table></figure>
<p>让redis开机自启</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/rc.local</span><br><span class="line">//添加</span><br><span class="line">/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis-conf</span><br></pre></td></tr></table></figure>
<p>至此redis已经全部安装完，后面我会分享redis.conf 详细配置以及说明。</p>
<ul>
<li><p>安装redis的一些问题</p>
<ol>
<li>若出现如下提示，则说明未安装gcc，使用命令安装gcc：apt-get install gcc </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-2.8.17]# make</span><br><span class="line">cd src &amp;&amp; make</span><br><span class="line">allmake[1]: Entering directory `/root/redis-2.8.17/src‘</span><br><span class="line">CC adlist.o</span><br><span class="line">/bin/sh:cc: command not found</span><br><span class="line">make[1]: *** [adlist.o] Error127</span><br><span class="line">make[1]: Leaving directory `/root/redis-2.8.17/src‘</span><br><span class="line">make: *** [all] Error2</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>若出现如下提示，则将make改为make MALLOC=libc，推测是因为编译库的问题。 </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-2.8.17]#make</span><br><span class="line">cd src &amp;&amp; make all</span><br><span class="line">make[1]: Entering directory `/root/redis-2.8.17/src‘</span><br><span class="line">CC adlist.o</span><br><span class="line">In file included from adlist.c:34:0:</span><br><span class="line">zmalloc.h:50:31: error: jemalloc/jemalloc.h: No suchfileor directory</span><br><span class="line">zmalloc.h:55:2: error:#error&quot;Newer version of jemalloc required&quot;</span><br><span class="line">make[1]: *** [adlist.o] Error1</span><br><span class="line">make[1]: Leaving directory `/root/redis-2.8.17/src‘</span><br><span class="line">make: *** [all] Error2</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>​     </p>
<h4 id="jekins的安装"><a href="#jekins的安装" class="headerlink" title="jekins的安装"></a>jekins的安装</h4><h5 id="下载程序包"><a href="#下载程序包" class="headerlink" title="下载程序包"></a>下载程序包</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirrors.jenkins.io/war/latest/jenkins.war</span><br></pre></td></tr></table></figure>
<h5 id="启动程序包"><a href="#启动程序包" class="headerlink" title="启动程序包"></a>启动程序包</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jarjenkins.war --httpPort=8081</span><br></pre></td></tr></table></figure>
<p>这里就相当于运行java程序，并且设置端口号为8081</p>
<p>当运行成功后就可以 使用浏览器进行访问</p>
<p>至于具体使用和配置可以参数 <a href="https://www.jianshu.com/p/36912a2bbaf9" target="_blank" rel="noopener">这个链接</a>。</p>
<h4 id="ssr的搭建"><a href="#ssr的搭建" class="headerlink" title="ssr的搭建"></a>ssr的搭建</h4><p>下载安装ssr程序安装程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</span><br></pre></td></tr></table></figure>
<p>然后按照安装程序走就行</p>
<p>如果希望查看ssr信息使用下面的命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash ssr.sh</span><br></pre></td></tr></table></figure>
<p>使用BBR加速</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh</span><br><span class="line"></span><br><span class="line">chmod +x bbr.sh</span><br><span class="line"></span><br><span class="line">./bbr.sh</span><br></pre></td></tr></table></figure>
<p>lsmod | grep bbr 如果出现tcp_bbr字样表示bbr已安装并启动成功</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/MayYJ/hexo/2018/03/09/javaweb/关于spring-data的坑/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="May">
      <meta itemprop="description" content="既然选择了远方，便只顾风雨兼程。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="May's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/09/javaweb/关于spring-data的坑/" itemprop="url">
                  关于spring-data
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Geplaatst op</span>
              

              
                
              

              <time title="Post aangemaakt: 2018-03-09 11:51:06" itemprop="dateCreated datePublished" datetime="2018-03-09T11:51:06+08:00">2018-03-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Post aangepast: 2018-05-26 17:27:55" itemprop="dateModified" datetime="2018-05-26T17:27:55+08:00">2018-05-26</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/javaweb/" itemprop="url" rel="index"><span itemprop="name">javaweb</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><p>只导入spring-date-redis是会在运行的时候报错的，需要自己导入下面两个包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>spring-data-redis 2.x 只适合spring5.x hespring boot2.x</p>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">May</p>
              <p class="site-description motion-element" itemprop="description">既然选择了远方，便只顾风雨兼程。</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">42</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">categorieën</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">labels</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright"> &copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">May</span>

  

  
</div>




  <div class="powered-by">Mede mogelijk gemaakt door <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Thema – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Muse</a> v6.4.2</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.2"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.2"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
