<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.4.2" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.2">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.4.2',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="IO模式异步IO用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。   阻塞和非阻塞 阻塞 在">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="nio">
<meta property="og:url" content="https://github.com/MayYJ/hexo/2018/05/05/IO/java nio/index.html">
<meta property="og:site_name" content="May&#39;s Blog">
<meta property="og:description" content="IO模式异步IO用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。   阻塞和非阻塞 阻塞 在">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/a67bf22fgy1fupj4idh0aj20fw0903zx.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/a67bf22fgy1fupj6q9kiqj20fc097t8n.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/a67bf22fgy1fupj8sj22xj20gr099aa4.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/a67bf22fgy1fupj7yfa1jj20gx092t8q.jpg">
<meta property="og:image" content="http://www.godpan.me/media/images/2017/11/java-nio.png">
<meta property="og:image" content="http://tutorials.jenkov.com/images/java-nio/buffers-modes.png">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2184951-a074ce9d4031bb7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/385/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2184951-327d066fab0e4047.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/488/format/web">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/1f5c2e595e41559ac0c829a96a918c15f4e.jpg">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/e9f813b5b08ac68021039ae5141c03f3cfc.jpg">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/1828d992e8821f9f093b6bf12c58732bb13.jpg">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/7ea7f4beb7b3c1d1c87d7b9e3bab8b6afb4.jpg">
<meta property="og:updated_time" content="2019-03-12T08:42:01.701Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="nio">
<meta name="twitter:description" content="IO模式异步IO用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。   阻塞和非阻塞 阻塞 在">
<meta name="twitter:image" content="https://ws1.sinaimg.cn/large/a67bf22fgy1fupj4idh0aj20fw0903zx.jpg">






  <link rel="canonical" href="https://github.com/MayYJ/hexo/2018/05/05/IO/java nio/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>nio | May's Blog</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">May's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">既然选择了远方，便只顾风雨兼程。</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/MayYJ/hexo/2018/05/05/IO/java nio/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="May">
      <meta itemprop="description" content="既然选择了远方，便只顾风雨兼程。">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="May's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">nio
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-05 17:41:16" itemprop="dateCreated datePublished" datetime="2018-05-05T17:41:16+08:00">2018-05-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-12 16:42:01" itemprop="dateModified" datetime="2019-03-12T16:42:01+08:00">2019-03-12</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="IO模式"><a href="#IO模式" class="headerlink" title="IO模式"></a>IO模式</h4><h5 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h5><p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。 </p>
<p><img src="https://ws1.sinaimg.cn/large/a67bf22fgy1fupj4idh0aj20fw0903zx.jpg" alt=""></p>
<h5 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h5><ul>
<li><p>阻塞</p>
<p>在等待数据就绪和复制数据阶段均阻塞。 </p>
<p><img src="https://ws1.sinaimg.cn/large/a67bf22fgy1fupj6q9kiqj20fc097t8n.jpg" alt=""></p>
</li>
<li><p>非阻塞</p>
<p>在等待数据就绪阶段，如果数据未就绪 read 会立刻返回 error，不阻塞；用户需要轮询以确认数据就绪；当就绪后则复制数据，该过程阻塞。 </p>
<p><img src="https://ws1.sinaimg.cn/large/a67bf22fgy1fupj8sj22xj20gr099aa4.jpg" alt=""></p>
</li>
</ul>
<h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h5><p>实现非阻塞</p>
<p>这个概念稍有不同，它是在执行 select() 的时候，同时阻塞多个 fd 然后等到监测到某些 fd 就绪时返回。此时进程两阶段均被阻塞，但等待数据就绪阶段由 select() 阻塞，复制数据阶段由 read() 阻塞。 </p>
<p><img src="https://ws1.sinaimg.cn/large/a67bf22fgy1fupj7yfa1jj20gx092t8q.jpg" alt=""></p>
<p>在BIO模型中，我们要实现非阻塞，由于不能知道什么时候可以从内核缓冲区中取数据又不想去浪费CPU资源，那么我们只能创建一个新的线程，然后使用新的线程去做接下来的事件然后等到可以取数据的时候，我们再去取。但是创建线程也是很消耗资源，而且当线程多了后切换线程也是很耗CPU资源的。所以在单线程下的IO多路复用的优点就凸显数来了，没有线程切换，只有拼命的读、写、选择事件，如果再利用好多核心进行IO那么效率还会有更大的提升</p>
<h5 id="Unix五种IO模型"><a href="#Unix五种IO模型" class="headerlink" title="Unix五种IO模型"></a>Unix五种IO模型</h5><ul>
<li>阻塞IO</li>
<li>非阻塞IO</li>
<li>IO复用（select、poll、epoll）</li>
<li>信号驱动IO</li>
<li>异步IO</li>
</ul>
<h5 id="Reactor和Proactor模式"><a href="#Reactor和Proactor模式" class="headerlink" title="Reactor和Proactor模式"></a>Reactor和Proactor模式</h5><p>其实java中Selector就是Reactor模式的实现，java中的AIO就是Proactor模式的实现；它们都要实现IO的多路复用，但是在事件分发者分发给事件处理者后（内核缓冲区数据准备好了）处理事件方式不一样；前者是同步的即在当前线程下处理IO任务（将内核缓冲区数据复制到用户空间），如果这个IO任务比较耗时就会比较浪费CPU资源；后者采用的方式的创建一个新的线程给事件处理者</p>
<h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><h5 id="NIO与传统IO的区别"><a href="#NIO与传统IO的区别" class="headerlink" title="NIO与传统IO的区别"></a>NIO与传统IO的区别</h5><ol>
<li>NIO面向缓冲，而传统IO面向流；传统IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方 </li>
<li>NIO是非阻塞的，而传统IO是阻塞的；在操作系统级别体现在当从IO设备接受数据的时候，在传统IO中当前线程需要等待设备控制器从IO设备中读取数据(虽然这个时候CPU与设备控制器是异步的)然后CPU再读取设备控制器中缓存的数据到内核内存里面；但是NIO会对前面这个过程进行异步，只有当IO设备里面的数据都到达了内核内存再通知操作系统(这里的通知的过程，我们完全可以参考后面对epoll的参考)</li>
</ol>
<h5 id="java-nio基本概念"><a href="#java-nio基本概念" class="headerlink" title="java nio基本概念"></a>java nio基本概念</h5><p>nio就是new io，是相对于传统的io模型来说的；java nio是一种基于多路复用模型的同步非阻塞的io模型 。相对于传统就一个io流就需要一个线程来进行连接处理，nio的处理方式更加的节约资源，增加系统的吞吐量。</p>
<h5 id="java-nio的实现"><a href="#java-nio的实现" class="headerlink" title="java nio的实现"></a>java nio的实现</h5><p><img src="http://www.godpan.me/media/images/2017/11/java-nio.png" alt="java-nio"></p>
<p>上面就是java nio的一种基本模型；一个线程对应一个selector，一个selector可以绑定多个Channel，一个Channel对应着一个Buffer。当然这只是通常的做法，一个Channel也可以对应多个Selector，一个Channel对应着多个Buffer。</p>
<h6 id="selector"><a href="#selector" class="headerlink" title="selector"></a>selector</h6><p>selector就是java nio实现多路复用的关键；在传统io中，一个socket我们必须用一个线程去管理；而在这里我们在io流和线程中间抽象出一个selector出来，selector就可以去管理多个io流连接从而实现多路链接    。</p>
<ul>
<li><p>创建selector</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>
</li>
<li><p>在selector上注册channel</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(false);</span><br><span class="line">channel.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure>
<p>这里的channel必须是非阻塞的，这里的第二个参数是表示channel对什么事件感兴趣，只有它感兴趣的事件selector才会分发给它，这里的事件有四种：</p>
<ol>
<li>Connect：一个channel成功连接到了其它服务器</li>
<li>Accept： 一个ServerSocketChannel接受到了一个连接</li>
<li>Read： 一个channel有数据等待读</li>
<li>Write：一个channel准备好了写数据</li>
</ol>
<p>这四个事件对应SelectionKey四个常量：</p>
<ol>
<li>SelectionKey.OP_CONNECT</li>
<li>SelectionKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ol>
<p>需要理解SelectionKey.OP_READ、SelectionKey.OP_WRITE的使用，为什么一般情况下在读取了数据需要重新注册其感兴趣的事件为SelectionKey.OP_WRITE，因为在非阻塞的情况下，比如调用了read 就会立马返回，操作系统并行的去帮我们完成读数据这件事情，但是我们不知道什么时候完成，所以如果我们注册了SelectionKey.OP_WRITE 那么就在完成的时候得到通知</p>
<p>如果想表示多个感兴趣的事件可以像如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SelectionKey</p>
<p>其实根据源码我们知道SelectionKey绑定了一个channel和selector，就是想表示一个事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final SelChImpl channel;</span><br><span class="line">public final SelectorImpl selector;</span><br><span class="line">private int index;</span><br><span class="line">private volatile int interestOps;</span><br><span class="line">private int readyOps;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>找到对应上面四种事件的SelectionKey</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过SelectionKey产生selector和channel</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Channel  channel  = selectionKey.channel();</span><br><span class="line">Selector selector = selectionKey.selector();</span><br></pre></td></tr></table></figure>
</li>
<li><p>附加数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.attach(theObject);</span><br><span class="line"></span><br><span class="line">Object attachedObj = selectionKey.attachment();</span><br></pre></td></tr></table></figure>
<p>又或者在注册的时候添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>通过selector选择channel</p>
<ol>
<li>select() 阻塞到至少有一个channel已经准备好了你注册的事件</li>
<li>int select(long timeout）和select()差不多，但是它最多阻塞timeout milliseconds </li>
<li>selectNow() 不阻塞，它会马上返回不管有没有channel准备好了</li>
</ol>
</li>
<li><p>关于源码</p>
<p><strong>selector 怎么过滤事件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是selector 监听得到的发生的感兴趣的事件</span></span><br><span class="line"><span class="keyword">protected</span> Set&lt;SelectionKey&gt; selectedKeys = <span class="keyword">new</span> HashSet();</span><br><span class="line"><span class="comment">// 这是用户注册的通道感兴趣的事件</span></span><br><span class="line"><span class="keyword">protected</span> HashSet&lt;SelectionKey&gt; keys = <span class="keyword">new</span> HashSet();</span><br><span class="line"><span class="comment">// 其实这两个都是上面两个的视图，read-only</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;SelectionKey&gt; publicKeys;</span><br><span class="line"><span class="keyword">private</span> Set&lt;SelectionKey&gt; publicSelectedKeys;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SelectorImpl</span><span class="params">(SelectorProvider var1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(var1);</span><br><span class="line">    <span class="keyword">if</span> (Util.atBugLevel(<span class="string">"1.4"</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.publicKeys = <span class="keyword">this</span>.keys;</span><br><span class="line">        <span class="keyword">this</span>.publicSelectedKeys = <span class="keyword">this</span>.selectedKeys;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.publicKeys = Collections.unmodifiableSet(<span class="keyword">this</span>.keys);</span><br><span class="line">        <span class="keyword">this</span>.publicSelectedKeys = Util.ungrowableSet(<span class="keyword">this</span>.selectedKeys);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注册channel</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(AbstractSelectableChannel var1, <span class="keyword">int</span> var2, Object var3)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!(var1 <span class="keyword">instanceof</span> SelChImpl)) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalSelectorException();</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           SelectionKeyImpl var4 = <span class="keyword">new</span> SelectionKeyImpl((SelChImpl)var1, <span class="keyword">this</span>);</span><br><span class="line">           var4.attach(var3);</span><br><span class="line">           Set var5 = <span class="keyword">this</span>.publicKeys;</span><br><span class="line">           <span class="keyword">synchronized</span>(<span class="keyword">this</span>.publicKeys) &#123;</span><br><span class="line">               <span class="keyword">this</span>.implRegister(var4);</span><br><span class="line">           &#125;</span><br><span class="line">  </span><br><span class="line">           var4.interestOps(var2);</span><br><span class="line">           <span class="keyword">return</span> var4;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>下面的代码会调用selector的以上代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>
<p>大致完成了 实例化了一个SelectionKey并绑定了selector和channel，并且把此SelectionKey加入到了selector中的key中</p>
</li>
</ul>
<h6 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h6><p>通道是java nio的第二个主要创新。它们既不是一个扩展也不是一项增强,而是全新、极好的 Java I/O 示例,提供与 I/O 服务的直接连接。Channel 用于在字节缓冲区和位于通道另一侧的实体(通常是一个文件或套接字)之间有效地传输数据。通道是一种途径,借助该途径,可以用最小的总开销来访问操作系统本身的 I/O 服务。</p>
<p><strong>channel有四种实现</strong></p>
<ol>
<li>FileChannel：操作文件</li>
<li>DatagramChannel：在网络上读或者写数据通过UDP</li>
<li>SocketChannel：在网络上读或者写数据通过TCP</li>
<li>ServerSocketChannel：监听TCP的连接，就像一个web服务器；每一个连接到来都会有一个SocketChannel生成</li>
</ol>
<p><strong>关于channel读数据</strong></p>
<p>因为在channel读数据的时候遇到了大大的坑 :angry:  NIO的API是真的有点难理解，真是搞飞机 :airplane: 所以在这里总结一下</p>
<p>处理读事件需要自己处理下列四种情况：</p>
<ol>
<li>channel还有数据，需要继续读</li>
<li>channel中暂时没有数据，但channel还没有断开，这时读取到的数据个数为0，结束读，继续到select()处阻塞等待数据</li>
<li>另外一端channel.close()关闭连接，这时候读channel返回的读取数是-1，表示已经到了到末尾，跟读文件一样；既然已经结束了，就把对应的SelectionKey给cancel掉，表示selector不再监听这个channel上的读事件；并且关闭连接，本端channel.close();</li>
<li>另一端被强制关闭,也就是channel没有close()就被强制断开了,这时候本端会抛出一个IOException:你的主机中的软件中止了一个已建立的连接的异常，要处理这个异常</li>
</ol>
<p><strong>关于channel使用的技巧</strong></p>
<p>是否还记得，SelectionKey的四个事件，我们这里不讲SelectionKey.OP_CONNECT,其实我们控制channel就是通过register方法来修改它所感兴趣的事件来实现接下来这个channel所要去做的事件</p>
<p>是不是读着有点模糊，下面我结合代码来分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>
<p>上面这段代码，因为其作为服务端作用只有监听端口，接收连接，所以我们通过这句代码来控制它只接收 连接到来的事件，但是这句代码不能说明修改感兴趣的事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">readDataFromChannel</span><span class="params">(SelectionKey selectionKey)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SocketChannel clientChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line">    StringBuilder readStr = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">while</span> ((len = clientChannel.read(buffer)) != <span class="number">0</span> &amp;&amp; len != -<span class="number">1</span>) &#123;</span><br><span class="line">        buffer.flip();</span><br><span class="line">        String str = <span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, len);</span><br><span class="line">        readStr.append(str);</span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    clientChannel.register(selector, SelectionKey.OP_WRITE);</span><br><span class="line">    <span class="keyword">return</span> readStr.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendData</span><span class="params">(SelectionKey selectionKey)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SocketChannel clientChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = response.getBytes();</span><br><span class="line">    byteBuffer.put(bytes);</span><br><span class="line">    byteBuffer.flip();</span><br><span class="line">    clientChannel.write(byteBuffer);</span><br><span class="line">    clientChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码就比较典型，在接收到内容后，我们需要马上进行回复，那么就需要把该channel感兴趣的事件修改为SelectionKey.OP_WRITE；然后在回复完数据后，又要回到等待接收数据，就需要把该channel感兴趣的事件修改为SelectionKey.OP_READ</p>
<h6 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h6><p>一个Buffer对象是固定数量的数据的容器。其作用是一个存储器,或者分段运输区,在这里数据可被存储并在之后用于检索。缓冲区的工作与通道紧密联系。通道是 I/O 传输发生时通过的入口,而缓冲区是这些数据传输的来源或目标。对于离开缓冲区的传输,您想传递出去的数据被置于一个缓冲区,被传送到通道。</p>
<p><strong>buffer的基础用法</strong></p>
<ol>
<li>写数据到buffer</li>
<li>buffer.flip()</li>
<li>从buffer读数据</li>
<li>buffer.clear() 或者 buffer.compact()</li>
</ol>
<p><strong>capacity、position、limit</strong></p>
<p>position、limit的含义取决于buffer是出于写模式还是读模式，capacity的含义在这两种模式下的意义都是一样的</p>
<p><img src="http://tutorials.jenkov.com/images/java-nio/buffers-modes.png" alt=""></p>
<p>在写模式下，position首先被置为0,limit被置为capacity，然后写一个数据类型的数据position就增加1，最大为capacity-1</p>
<p>当通过flip()变为读模式时，position变为0，limit变为写数据时写到最大的position位置，也就是只能从position读到limit</p>
<p><strong>Buffer类型</strong></p>
<ul>
<li>ByteBuffer</li>
<li>MappedByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p><strong>分配Buffer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">CharBuffer buf = CharBuffer.allocate(1024);</span><br></pre></td></tr></table></figure>
<p><strong>通过Buffer传输数据</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int bytesRead = inChannel.read(buf); //read into buffer.</span><br><span class="line"></span><br><span class="line">buf.put(127);</span><br></pre></td></tr></table></figure>
<p><strong>flip()</strong></p>
<p>从写模式换到读模式，具体的代码实现就是，将position置为0，limit设置为上一次position的位置</p>
<p>下面是一段怎么将ByteBuffer里面的数据转换为utf-8数据</p>
<p><strong>clear() and compact()</strong></p>
<p>读完数据后可以通过clear()方法重新加入数据</p>
<p>当你从Buffer中没有读完数据，但是想要写数据，然后在读剩下的数据就用compact，具体实现就是把所有没有读的数据复制到buffer开始，position设置到没有读完的数据的右边</p>
<p>mark() and reset()</p>
<p>记住position</p>
<p>将position 设置到上一次mark记住position的位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getBufferString</span><span class="params">(ByteBuffer buffer)</span></span>&#123;</span><br><span class="line">    Charset charset = <span class="keyword">null</span>;</span><br><span class="line">    CharsetDecoder decoder = <span class="keyword">null</span>;</span><br><span class="line">    CharBuffer charBuffer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        charset = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line">        decoder = charset.newDecoder();</span><br><span class="line">        <span class="comment">// charBuffer = decoder.decode(buffer);//用这个的话，只能输出来一次结果，第二次显示为空</span></span><br><span class="line">        charBuffer = decoder.decode(buffer.asReadOnlyBuffer());</span><br><span class="line">        <span class="keyword">return</span> charBuffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="在java-nio中同步非阻塞的实现方式"><a href="#在java-nio中同步非阻塞的实现方式" class="headerlink" title="在java nio中同步非阻塞的实现方式"></a>在java nio中同步非阻塞的实现方式</h5><p>因为java nio是在传统io中包装过来的，所以它的本质还是同步的，而它的非阻塞就是通过channel是实现的。在代码中我们通常通过 循环selector.select()来得到连接或者待读取的通道，这里都是同步的；当得到一个连接准备写入或者读取数据的时候也就是channel的write和read方法会异步的进行，也就是在执行write方法时在还没有进行数据写进buffer之前就返回了，read同理在没有读数据到Buffer的时候就已经返回，而是通过开启一个新的线程来完成写入和读取操作。</p>
<h5 id="select、poll、epoll"><a href="#select、poll、epoll" class="headerlink" title="select、poll、epoll"></a>select、poll、epoll</h5><p>这三者都是IO多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。</p>
<ul>
<li><p>Linux的socket事件wakeup callback机制</p>
<p>在介绍<code>select</code>、<code>poll</code>和<code>epoll</code>前，有必要说说Linux（2.6+）内核的事件wakeup callback机制，这是IO多路复用机制存在的本质。Linux通过socket睡眠队列来管理所有等待socket的某个事件的进程（Process），同时通过<code>wakeup</code>机制来异步唤醒整个睡眠队列上等待事件的Process，通知Process相关事件发生。</p>
</li>
</ul>
<p><strong>select</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</span><br></pre></td></tr></table></figure>
<p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。 </p>
<p>我大致讲一下其过程：</p>
<ol>
<li>当调用select 函数时，会将感兴趣的所有fd_set 从用户空间复制到内核空间</li>
<li>当前线程会被加入到每个监控的Socket上的等待队列上面睡眠</li>
<li>当Socket上有事件发生的时候修改复制进来的fd_set，唤醒等待的线程，等待的线程在继续执行遍历fd_set得到发生准备好的socket</li>
</ol>
<p>select 主要有两个问题：</p>
<ol>
<li>可监控的fds太少 只能是1024</li>
<li>每次都要遍历 fd_set,比较的耗时</li>
</ol>
<p><strong>poll</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int poll (struct pollfd *fds, unsigned int nfds, int timeout);</span><br></pre></td></tr></table></figure>
<p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct pollfd &#123;</span><br><span class="line">    int fd; /* file descriptor */</span><br><span class="line">    short events; /* requested events to watch */</span><br><span class="line">    short revents; /* returned events witnessed */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。 和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。 </p>
<p>poll 只是把感兴趣事件的数据结构改了，支持监控更多的socket</p>
<p><strong>epoll</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size)；</span><br><span class="line"><span class="comment">//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，调用这个方法就会产生一个如下的结构体</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span>&#123;</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span>  <span class="title">rbr</span>;</span></span><br><span class="line">    <span class="comment">/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdlist</span>;</span></span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//我觉得rbr是在用户注册完需要监听的端口的所有事件后，系统在接受到一个请求后就会把此事件与这个红黑树rbr中的所有事件进行比较，如果有的话就会加入到rdlist，所以在用户不用遍历所有监听的端口而是只用遍历rdlist就可以得到所有可以读取的流</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span></span><br><span class="line"><span class="function"><span class="comment">//创建需要监听的事件</span></span></span><br><span class="line">epfd epoll的句柄id</span><br><span class="line">op 操作即是要对fd即端口删除、增加还是修改event，所有op对应 添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD</span><br><span class="line">fd 监听的端口对应的句柄</span><br><span class="line">event 进行op操作的所有事件</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">//从内核得到事件集合，返回需要处理的事件数目</span></span><br></pre></td></tr></table></figure>
<p>以上我们可以得出epoll相对于select和poll的优点：</p>
<ol>
<li>没有注册描述符的限制，也就是没有监听端口的限制，也不会因为监听端口的增加而性能降低</li>
<li>不用去遍历所有流得到能读或者写的流，epoll已经把哪个流产生了怎样的IO事件通知了我们，我们直接取出来即可</li>
</ol>
<h4 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h4><p>在我看来一下的两种方式其实都是通过一种方式来进行异步的：先是通过多路复用也就是Nio来实现非阻塞，然后再通过创建线程做其它事情的方式避免等待从内核缓冲区向用户空间复制数据</p>
<p>所以它们有一个共同点就是要先在用户空间创建buffer</p>
<p><strong>Future方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">    Path path =                                               Paths.get(<span class="string">"/data/code/github/java_practice/src/main/resources/1log4j.properties"</span>);</span><br><span class="line">    AsynchronousFileChannel channel = AsynchronousFileChannel.open(path);</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    Future future = channel.read(buffer,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//        while (!future.isDone())&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println("I'm idle");</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//我们可以在这里做其它事情</span></span><br><span class="line">    Integer readNumber = future.get();</span><br><span class="line"></span><br><span class="line">    buffer.flip();</span><br><span class="line">    CharBuffer charBuffer = CharBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    CharsetDecoder decoder = Charset.defaultCharset().newDecoder();</span><br><span class="line">    decoder.decode(buffer,charBuffer,<span class="keyword">false</span>);</span><br><span class="line">    charBuffer.flip();</span><br><span class="line">    String data = <span class="keyword">new</span> String(charBuffer.array(),<span class="number">0</span>, charBuffer.limit());</span><br><span class="line">    System.out.println(<span class="string">"read number:"</span> + readNumber);</span><br><span class="line">    System.out.println(data);</span><br></pre></td></tr></table></figure>
<p>因为Future的本质就是直接返回而创建新的线程运算得到结果，运算结束后自己去取结果</p>
<p><strong>回调方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">"/data/code/github/java_practice/src/main/resources/1log4j.properties"</span>);</span><br><span class="line">AsynchronousFileChannel channel = AsynchronousFileChannel.open(path);</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">channel.read(buffer, <span class="number">0</span>, buffer, <span class="keyword">new</span> CompletionHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" read success!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"read error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">" sleep"</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建新的线程从内核取数据，所以completed方法也是在新线程上完成的</p>
<h4 id="从JAVA-源码分析NIO"><a href="#从JAVA-源码分析NIO" class="headerlink" title="从JAVA 源码分析NIO"></a>从JAVA 源码分析NIO</h4><h5 id="用NIO-实现一个简单的服务器"><a href="#用NIO-实现一个简单的服务器" class="headerlink" title="用NIO 实现一个简单的服务器"></a>用NIO 实现一个简单的服务器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">       ServerSocket serverSocket = serverSocketChannel.socket();</span><br><span class="line">       serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(PORT));</span><br><span class="line">       selector = Selector.open();</span><br><span class="line">       serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">       serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">           <span class="keyword">if</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">               Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line"></span><br><span class="line">               <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                   SelectionKey selectionKey = iterator.next();</span><br><span class="line">                   iterator.remove();</span><br><span class="line">                   <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">                       SocketChannel client = ((ServerSocketChannel)selectionKey.channel()).accept();</span><br><span class="line">                       client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                       client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">                       readData((SocketChannel) selectionKey.channel());</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (selectionKey.isConnectable()) &#123;</span><br><span class="line">                       System.out.println(<span class="string">"isConnectable == true"</span>);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们就按照代码的逻辑思考底层是怎么实现的</p>
<h5 id="Selector-open"><a href="#Selector-open" class="headerlink" title="Selector.open()"></a>Selector.open()</h5><p>Selector 是Java NIO实现的核心，那么它是怎么怎么得到的，它是什么呢？</p>
<p>Selector 是通过SelectorProvider 得到的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">provider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (provider != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> provider;</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> PrivilegedAction&lt;SelectorProvider&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> SelectorProvider <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (loadProviderFromProperty())</span><br><span class="line">                            <span class="keyword">return</span> provider;</span><br><span class="line">                        <span class="keyword">if</span> (loadProviderAsService())</span><br><span class="line">                            <span class="keyword">return</span> provider;</span><br><span class="line">                        provider = sun.nio.ch.DefaultSelectorProvider.create();</span><br><span class="line">                        <span class="keyword">return</span> provider;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SelectorProvider 是一个桥连接实现的典型</p>
<p>本身SelectorProvider有自己的实现方式，在Linux和Windows下实现方式不同，然后它通过组合的方式成为比如说Selector的一个属性，然后Selector又有自己的不同实现，当然还有ServerSocketChannel</p>
<p>下面是Windows下Selector的一种实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">WindowsSelectorImpl(SelectorProvider sp) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">super</span>(sp);</span><br><span class="line">    <span class="comment">// pollWrapper 是多路复用实现的关键；这个对象直接操作内存，将Socket句柄和感兴趣的事件保存保存下来</span></span><br><span class="line">    pollWrapper = <span class="keyword">new</span> PollArrayWrapper(INIT_CAP);</span><br><span class="line">    <span class="comment">// Pipe 是一种管道，既可以读也可以写</span></span><br><span class="line">    <span class="comment">// wakeupPipe 的实现是为了实现唤醒阻塞等待的Selector，下面会讲是怎么实现的</span></span><br><span class="line">    wakeupPipe = Pipe.open();</span><br><span class="line">    wakeupSourceFd = ((SelChImpl)wakeupPipe.source()).getFDVal();</span><br><span class="line"></span><br><span class="line">    SinkChannelImpl sink = (SinkChannelImpl)wakeupPipe.sink();</span><br><span class="line">    (sink.sc).socket().setTcpNoDelay(<span class="keyword">true</span>);</span><br><span class="line">    wakeupSinkFd = ((SelChImpl)sink).getFDVal();</span><br><span class="line"></span><br><span class="line">    pollWrapper.addWakeupSocket(wakeupSourceFd, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="pollWrapper"><a href="#pollWrapper" class="headerlink" title="pollWrapper"></a>pollWrapper</h5><p><strong>pollWrapper</strong>用Unsafe类申请一块物理内存pollfd，存放socket句柄fdVal和events，其中pollfd共8位，0-3位保存socket句柄，4-7位保存events。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2184951-a074ce9d4031bb7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/385/format/webp" alt=""></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2184951-327d066fab0e4047.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/488/format/web" alt=""></p>
<p>pollWrapper提供了fdVal和event数据的相应操作，如添加操作通过Unsafe的putInt和putShort实现。</p>
<h5 id="serverSocketChannel-register"><a href="#serverSocketChannel-register" class="headerlink" title="serverSocketChannel.register()"></a>serverSocketChannel.register()</h5><p>这个方法其实 会调用Selector.register()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SelectorImpl</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(AbstractSelectableChannel ch,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> ops,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Object attachment)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!(ch <span class="keyword">instanceof</span> SelChImpl))</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalSelectorException();</span><br><span class="line">     SelectionKeyImpl k = <span class="keyword">new</span> SelectionKeyImpl((SelChImpl)ch, <span class="keyword">this</span>);</span><br><span class="line">     k.attach(attachment);</span><br><span class="line">     <span class="keyword">synchronized</span> (publicKeys) &#123;</span><br><span class="line">         implRegister(k);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 添加感兴趣的事件</span></span><br><span class="line">     k.interestOps(ops);</span><br><span class="line">     <span class="keyword">return</span> k;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">implRegister</span><span class="params">(SelectionKeyImpl ski)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span> (closeLock) &#123;</span><br><span class="line">         <span class="keyword">if</span> (pollWrapper == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ClosedSelectorException();</span><br><span class="line">         growIfNeeded();</span><br><span class="line">         channelArray[totalChannels] = ski;</span><br><span class="line">         ski.setIndex(totalChannels);</span><br><span class="line">         fdMap.put(ski);</span><br><span class="line">         keys.add(ski);</span><br><span class="line">         <span class="comment">// 添加Socket句柄</span></span><br><span class="line">         pollWrapper.addEntry(totalChannels, ski);</span><br><span class="line">         totalChannels++;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>生成SelectionKey并添加附件attachment</li>
<li>如果当前channel的数量totalChannels等于SelectionKeyImpl数组大小，对SelectionKeyImpl数组和pollWrapper进行扩容操作。</li>
<li>如果totalChannels % MAX_SELECTABLE_FDS == 0，则多开一个线程处理selector</li>
<li>将SelectionKey 做上Index标记，标志Socket句柄在内存上的偏移量</li>
<li>通过刚刚的Index属性添加 Socket句柄到对应的pollfd</li>
<li>通过Index属性添加感兴趣的事件到对应的pollfd的event</li>
</ol>
<h5 id="doSelect"><a href="#doSelect" class="headerlink" title="doSelect()"></a>doSelect()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doSelect</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.channelArray == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ClosedSelectorException();</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">         <span class="keyword">this</span>.processDeregisterQueue();</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.interruptTriggered) &#123;</span><br><span class="line">             <span class="keyword">this</span>.resetWakeupSocket();</span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">this</span>.adjustThreadsCount();</span><br><span class="line">             <span class="keyword">this</span>.finishLock.reset();</span><br><span class="line">             <span class="keyword">this</span>.startLock.startThreads();</span><br><span class="line"></span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="keyword">this</span>.begin();</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     <span class="keyword">this</span>.subSelector.poll();</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (IOException var7) &#123;</span><br><span class="line">                     <span class="keyword">this</span>.finishLock.setException(var7);</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">if</span> (<span class="keyword">this</span>.threads.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                     <span class="keyword">this</span>.finishLock.waitForHelperThreads();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                 <span class="keyword">this</span>.end();</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">this</span>.finishLock.checkForException();</span><br><span class="line">             <span class="keyword">this</span>.processDeregisterQueue();</span><br><span class="line">             <span class="keyword">int</span> var3 = <span class="keyword">this</span>.updateSelectedKeys();</span><br><span class="line">             <span class="keyword">this</span>.resetWakeupSocket();</span><br><span class="line">             <span class="keyword">return</span> var3;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>其中 subSelector.poll() 是select的核心，由native函数poll0实现，readFds、writeFds 和exceptFds数组用来保存底层select的结果，数组的第一个位置都是存放发生事件的socket的总数，其余位置存放发生事件的socket句柄fd。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] readFds = <span class="keyword">new</span> <span class="keyword">int</span> [MAX_SELECTABLE_FDS + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] writeFds = <span class="keyword">new</span> <span class="keyword">int</span> [MAX_SELECTABLE_FDS + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] exceptFds = <span class="keyword">new</span> <span class="keyword">int</span> [MAX_SELECTABLE_FDS + <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123; <span class="comment">// poll for the main thread</span></span><br><span class="line">    <span class="comment">// 第一个参数是pollfd 数组的首地址，第二个参数就可以得到监控的所有channel,也就是Socket</span></span><br><span class="line">     <span class="keyword">return</span> poll0(pollWrapper.pollArrayAddress,</span><br><span class="line">          Math.min(totalChannels, MAX_SELECTABLE_FDS),</span><br><span class="line">             readFds, writeFds, exceptFds, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>如果之前没有发生事件，程序就阻塞在select处，当然不会一直阻塞，因为epoll在timeout时间内如果没有事件，也会返回；</li>
<li>一旦有对应的事件发生，poll0方法就会返回；</li>
<li>processDeregisterQueue方法会清理那些已经cancelled的SelectionKey；</li>
<li>updateSelectedKeys方法统计有事件发生的SelectionKey数量，并把符合条件发生事件的SelectionKey添加到selectedKeys哈希表中，并且把SelectionKey的readyOps修改为true</li>
</ol>
<h5 id="wakeUp"><a href="#wakeUp" class="headerlink" title="wakeUp()"></a>wakeUp()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Selector <span class="title">wakeup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (interruptLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!interruptTriggered) &#123;</span><br><span class="line">            setWakeupSocket();</span><br><span class="line">            interruptTriggered = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sets Windows wakeup socket to a signaled state.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setWakeupSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   setWakeupSocket0(wakeupSinkFd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">setWakeupSocket0</span><span class="params">(<span class="keyword">int</span> wakeupSinkFd)</span></span>;</span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_sun_nio_ch_WindowsSelectorImpl_setWakeupSocket0(JNIEnv *env, jclass <span class="keyword">this</span>,</span><br><span class="line">                                                jint scoutFd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Write one byte into the pipe */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> <span class="keyword">byte</span> = <span class="number">1</span>;</span><br><span class="line">    send(scoutFd, &amp;<span class="keyword">byte</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见wakeup()是通过pipe的write 端send(scoutFd, &amp;byte, 1, 0)，发生一个字节1，来唤醒poll（）。所以在需要的时候就可以调用selector.wakeup()来唤醒selector。</p>
<h4 id="epoll-实现原理"><a href="#epoll-实现原理" class="headerlink" title="epoll 实现原理"></a>epoll 实现原理</h4><p>epoll是Linux下的一种IO多路复用技术，可以非常高效的处理数以百万计的socket句柄。</p>
<p>三个epoll相关的系统调用：</p>
<ul>
<li><strong>int epoll_create(int size)</strong><br>epoll_create建立一个epoll对象。参数size是内核保证能够正确处理的最大句柄数，多于这个最大数时内核可不保证效果。</li>
<li><strong>int epoll_ctl(int epfd, int op, int fd, struct epoll_event event)</strong><br>epoll_ctl可以操作epoll_create创建的epoll，如将socket句柄加入到epoll中让其监控，或把epoll正在监控的某个socket句柄移出epoll。</li>
<li><strong>int epoll_wait(int epfd, struct epoll_event events,int maxevents, int timeout)</strong><br>epoll_wait在调用时，在给定的timeout时间内，所监控的句柄中有事件发生时，就返回用户态的进程。</li>
</ul>
<p>epoll内部实现大概如下：</p>
<ol>
<li>epoll初始化时，会向内核注册一个文件系统，用于存储被监控的句柄文件，调用epoll_create时，会在这个文件系统中创建一个file节点。同时epoll会开辟自己的内核高速缓存区，以红黑树的结构保存句柄，以支持快速的查找、插入、删除。还会再建立一个list链表，用于存储准备就绪的事件。</li>
<li>当执行epoll_ctl时，除了把socket句柄放到epoll文件系统里file对象对应的红黑树上之外，还会给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表里。所以，当一个socket上有数据到了，内核在把网卡上的数据copy到内核中后，就把socket插入到就绪链表里。</li>
<li>当epoll_wait调用时，仅仅观察就绪链表里有没有数据，如果有数据就返回，否则就sleep，超时时立刻返回。</li>
</ol>
<h4 id="流和channel的不同"><a href="#流和channel的不同" class="headerlink" title="流和channel的不同"></a>流和channel的不同</h4><h4 id="Reactor模型-反应堆模型"><a href="#Reactor模型-反应堆模型" class="headerlink" title="Reactor模型(反应堆模型)"></a>Reactor模型(反应堆模型)</h4><ul>
<li>什么是Reactor</li>
</ul>
<p>下面是来自Wiki的解释：</p>
<p>The reactor design pattern is an event handling pattern for handling service requests delivered concurrently to a service handler by one or more inputs. The service handler then demultiplexes the incoming requests and dispatches them synchronously to the associated request handlers.</p>
<p>其中关键点为：</p>
<ol>
<li>事件驱动，即由某个事件的发生触发</li>
<li>可以处理一个或多个输入源</li>
<li>通过Service Handler同步的将输入事件（Event）采用多路复用分发给相应的Request Handler（多个）处理（注意这里有两个handler,一个ServiceHandler，一个Request Handler）</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/1f5c2e595e41559ac0c829a96a918c15f4e.jpg" alt=""></p>
<p>需要知道的是，Reactor模式是建立在Java NIO之上的，它只是一个很好的模式去连接事件和其相关联的事件处理器；它其实是一个流程化的过程，只是在JAVA 中用面向对象思想去建立这样的模型</p>
<ul>
<li><p>Reactor</p>
<p>在反应堆模型中有三个角色，分别是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. Reactor 将IO事件分派给对应的handler</span><br><span class="line"><span class="number">2</span>. Acceptor 处理客户端连接，并分派请求到处理器链中</span><br><span class="line"><span class="number">3</span>. Handlers 执行非阻塞读/写 任务</span><br></pre></td></tr></table></figure>
<ol>
<li><p>单Reactor单线程模型</p>
<p><img src="https://oscimg.oschina.net/oscnet/e9f813b5b08ac68021039ae5141c03f3cfc.jpg" alt=""></p>
<p>概述一下其过程吧：</p>
<ul>
<li>客户端的连接会被分发器分发给accptor进行 SocketChannel的获取并将其处理器附加到SelectionKey上，以便后面事件发生的时候获取并处理</li>
<li>当触发的事件发生比如说SocketChannel上有可以读或者可以写的事件发生，会通过分发器去获取SelectionKey上对应的处理器去执行</li>
</ul>
<p>下面是用代码模拟的模型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 等待事件到来，分发事件处理</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Reactor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">​</span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">Reactor</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">​</span><br><span class="line">          SelectionKey sk =</span><br><span class="line">                  serverSocket.register(selector,</span><br><span class="line">                          SelectionKey.OP_ACCEPT);</span><br><span class="line">          <span class="comment">// attach Acceptor 处理新连接</span></span><br><span class="line">          sk.attach(<span class="keyword">new</span> Acceptor());</span><br><span class="line">      &#125;</span><br><span class="line">​</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                  selector.select();</span><br><span class="line">                  Set selected = selector.selectedKeys();</span><br><span class="line">                  Iterator it = selected.iterator();</span><br><span class="line">                  <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                      it.remove();</span><br><span class="line">                      <span class="comment">//分发事件处理</span></span><br><span class="line">                      dispatch((SelectionKey) (it.next()));</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">              <span class="comment">//do something</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">​</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(SelectionKey k)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 若是连接事件获取是acceptor</span></span><br><span class="line">          <span class="comment">// 若是IO读写事件获取是handler</span></span><br><span class="line">          Runnable runnable = (Runnable) (k.attachment());</span><br><span class="line">          <span class="keyword">if</span> (runnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">              runnable.run();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">​</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 连接事件就绪,处理连接事件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              SocketChannel c = serverSocket.accept();</span><br><span class="line">              <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;<span class="comment">// 注册读写</span></span><br><span class="line">                  <span class="keyword">new</span> Handler(c, selector);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">​</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 处理读写业务逻辑</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READING = <span class="number">0</span>, WRITING = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> state;</span><br><span class="line">      <span class="keyword">final</span> SocketChannel socket;</span><br><span class="line">      <span class="keyword">final</span> SelectionKey sk;</span><br><span class="line">​</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(SocketChannel socket, Selector sl)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.state = READING;</span><br><span class="line">          <span class="keyword">this</span>.socket = socket;</span><br><span class="line">          sk = socket.register(selector, SelectionKey.OP_READ);</span><br><span class="line">          sk.attach(<span class="keyword">this</span>);</span><br><span class="line">          socket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">​</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (state == READING) &#123;</span><br><span class="line">              read();</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == WRITING) &#123;</span><br><span class="line">              write();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">​</span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          process();</span><br><span class="line">          <span class="comment">//下一步处理写事件</span></span><br><span class="line">          sk.interestOps(SelectionKey.OP_WRITE);</span><br><span class="line">          <span class="keyword">this</span>.state = WRITING;</span><br><span class="line">      &#125;</span><br><span class="line">​</span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          process();</span><br><span class="line">          <span class="comment">//下一步处理读事件</span></span><br><span class="line">          sk.interestOps(SelectionKey.OP_READ);</span><br><span class="line">          <span class="keyword">this</span>.state = READING;</span><br><span class="line">      &#125;</span><br><span class="line">​</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * task 业务处理</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">//do something</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>因为整个过程都是在单线程下的，不能充分利用CPU的资源,且如果处理过程比较复杂会将整个过程阻塞，不能接受新的连接，所以衍生出了下面的模型</p>
</li>
<li><p>单Reactor多线程模型</p>
<p><img src="https://oscimg.oschina.net/oscnet/1828d992e8821f9f093b6bf12c58732bb13.jpg" alt=""></p>
<p>在这个模型下，其实其它都没有太多改变，就是添加了一个线程池去完成对读和写的过程的处理，</p>
<p>其代码实现过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 多线程处理读写业务逻辑</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READING = <span class="number">0</span>, WRITING = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> state;</span><br><span class="line">      <span class="keyword">final</span> SocketChannel socket;</span><br><span class="line">      <span class="keyword">final</span> SelectionKey sk;</span><br><span class="line">​</span><br><span class="line">      <span class="comment">//多线程处理业务逻辑</span></span><br><span class="line">      ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">MultiThreadHandler</span><span class="params">(SocketChannel socket, Selector sl)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.state = READING;</span><br><span class="line">          <span class="keyword">this</span>.socket = socket;</span><br><span class="line">          sk = socket.register(selector, SelectionKey.OP_READ);</span><br><span class="line">          sk.attach(<span class="keyword">this</span>);</span><br><span class="line">          socket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">​</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (state == READING) &#123;</span><br><span class="line">              read();</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == WRITING) &#123;</span><br><span class="line">              write();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">​</span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">//任务异步处理</span></span><br><span class="line">          executorService.submit(() -&gt; process());</span><br><span class="line">​</span><br><span class="line">          <span class="comment">//下一步处理写事件</span></span><br><span class="line">          sk.interestOps(SelectionKey.OP_WRITE);</span><br><span class="line">          <span class="keyword">this</span>.state = WRITING;</span><br><span class="line">      &#125;</span><br><span class="line">​</span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">//任务异步处理</span></span><br><span class="line">          executorService.submit(() -&gt; process());</span><br><span class="line">​</span><br><span class="line">          <span class="comment">//下一步处理读事件</span></span><br><span class="line">          sk.interestOps(SelectionKey.OP_READ);</span><br><span class="line">          <span class="keyword">this</span>.state = READING;</span><br><span class="line">      &#125;</span><br><span class="line">​</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * task 业务处理</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">//do IO ,task,queue something</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多Reactor多线程模型</p>
<p><img src="https://oscimg.oschina.net/oscnet/7ea7f4beb7b3c1d1c87d7b9e3bab8b6afb4.jpg" alt=""></p>
<p>该模型后面的处理流程都与前面的模型一样，在单Reactor多线程模型下，连接的处理和去执行处理器是一个线性的过程，在该模型下，把连接的注册过程分离了出来</p>
<p>mainReactor负责连接顺序的注册到subReactor上，subReactor管理自己的selector，对其上的SocketChannel进行监听</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 多work 连接事件Acceptor,处理连接事件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MultiWorkThreadAcceptor</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">​</span><br><span class="line">      <span class="comment">// cpu线程数相同多work线程</span></span><br><span class="line">      int workCount =Runtime.getRuntime().availableProcessors();</span><br><span class="line">      SubReactor[] workThreadHandlers = <span class="keyword">new</span> SubReactor[workCount];</span><br><span class="line">      volatile int nextHandler = <span class="number">0</span>;</span><br><span class="line">​</span><br><span class="line">      public MultiWorkThreadAcceptor() &#123;</span><br><span class="line">          <span class="keyword">this</span>.init();</span><br><span class="line">      &#125;</span><br><span class="line">​</span><br><span class="line">      public <span class="keyword">void</span> init() &#123;</span><br><span class="line">          nextHandler = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; workThreadHandlers.length; i++) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  workThreadHandlers[i] = <span class="keyword">new</span> SubReactor();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              &#125;</span><br><span class="line">​</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">​</span><br><span class="line">      @Override</span><br><span class="line">      public <span class="keyword">void</span> run() &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              SocketChannel c = serverSocket.accept();</span><br><span class="line">              <span class="keyword">if</span> (c != <span class="literal">null</span>) &#123;<span class="comment">// 注册读写</span></span><br><span class="line">                  synchronized (c) &#123;</span><br><span class="line">                      <span class="comment">// 顺序获取SubReactor，然后注册channel </span></span><br><span class="line">                      SubReactor work = workThreadHandlers[nextHandler];</span><br><span class="line">                      work.registerChannel(c);</span><br><span class="line">                      nextHandler++;</span><br><span class="line">                      <span class="keyword">if</span> (nextHandler &gt;= workThreadHandlers.length) &#123;</span><br><span class="line">                          nextHandler = <span class="number">0</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 多work线程处理读写业务逻辑</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">SubReactor</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">      final Selector mySelector;</span><br><span class="line">​</span><br><span class="line">      <span class="comment">//多线程处理业务逻辑</span></span><br><span class="line">      int workCount =Runtime.getRuntime().availableProcessors();</span><br><span class="line">      ExecutorService executorService = Executors.newFixedThreadPool(workCount);</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line">      public SubReactor() throws Exception &#123;</span><br><span class="line">          <span class="comment">// 每个SubReactor 一个selector </span></span><br><span class="line">          <span class="keyword">this</span>.mySelector = SelectorProvider.provider().openSelector();</span><br><span class="line">      &#125;</span><br><span class="line">​</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 注册chanel</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * @param sc</span></span><br><span class="line"><span class="comment">        * @throws Exception</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">      public <span class="keyword">void</span> registerChannel(SocketChannel sc) throws Exception &#123;</span><br><span class="line">          sc.register(mySelector, SelectionKey.OP_READ | SelectionKey.OP_CONNECT);</span><br><span class="line">      &#125;</span><br><span class="line">​</span><br><span class="line">      @Override</span><br><span class="line">      public <span class="keyword">void</span> run() &#123;</span><br><span class="line">          <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">//每个SubReactor 自己做事件分派处理读写事件</span></span><br><span class="line">                  selector.select();</span><br><span class="line">                  <span class="built_in">Set</span>&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">                  Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</span><br><span class="line">                  <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                      SelectionKey key = iterator.next();</span><br><span class="line">                      iterator.remove();</span><br><span class="line">                      <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                          read();</span><br><span class="line">                      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">                          write();</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">​</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">​</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">​</span><br><span class="line">      private <span class="keyword">void</span> read() &#123;</span><br><span class="line">          <span class="comment">//任务异步处理</span></span><br><span class="line">          executorService.submit(() -&gt; process());</span><br><span class="line">      &#125;</span><br><span class="line">​</span><br><span class="line">      private <span class="keyword">void</span> write() &#123;</span><br><span class="line">          <span class="comment">//任务异步处理</span></span><br><span class="line">          executorService.submit(() -&gt; process());</span><br><span class="line">      &#125;</span><br><span class="line">​</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * task 业务处理</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">      public <span class="keyword">void</span> process() &#123;</span><br><span class="line">          <span class="comment">//do IO ,task,queue something</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>Linux io模式、select、poll、epoll</p>
<p><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">https://segmentfault.com/a/1190000003063859</a></p>
<p><a href="https://blog.csdn.net/tianjing0805/article/details/76021440" target="_blank" rel="noopener">https://blog.csdn.net/tianjing0805/article/details/76021440</a></p>
<p><a href="https://juejin.im/entry/5b6058fde51d45348a2ffc65" target="_blank" rel="noopener">这篇很好</a></p>
<p>Aio</p>
<p><a href="https://juejin.im/entry/583ec2e3128fe1006bfa6c83" target="_blank" rel="noopener">https://juejin.im/entry/583ec2e3128fe1006bfa6c83</a></p>
<p>NIO</p>
<p><a href="http://tutorials.jenkov.com/java-nio/buffers.html" target="_blank" rel="noopener">http://tutorials.jenkov.com/java-nio/buffers.html</a></p>
<p>NIO 源码</p>
<p><a href="https://www.jianshu.com/p/0d497fe5484a" target="_blank" rel="noopener">https://www.jianshu.com/p/0d497fe5484a</a></p>
<p><a href="https://my.oschina.net/u/2337927/blog/523366" target="_blank" rel="noopener">https://my.oschina.net/u/2337927/blog/523366</a></p>
<p>反应堆</p>
<p><a href="https://blog.csdn.net/qq924862077/article/details/81026740" target="_blank" rel="noopener">https://blog.csdn.net/qq924862077/article/details/81026740</a></p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/13/Java 基础/ArrayList源码解析/" rel="next" title="ArrayList源码解析">
                <i class="fa fa-chevron-left"></i> ArrayList源码解析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/12/Java 基础/java序列化/" rel="prev" title="java序列化">
                java序列化 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="May">
            
              <p class="site-author-name" itemprop="name">May</p>
              <p class="site-description motion-element" itemprop="description">既然选择了远方，便只顾风雨兼程。</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">77</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">53</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#IO模式"><span class="nav-number">1.</span> <span class="nav-text">IO模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#异步IO"><span class="nav-number">1.1.</span> <span class="nav-text">异步IO</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#阻塞和非阻塞"><span class="nav-number">1.2.</span> <span class="nav-text">阻塞和非阻塞</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#多路复用"><span class="nav-number">1.3.</span> <span class="nav-text">多路复用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Unix五种IO模型"><span class="nav-number">1.4.</span> <span class="nav-text">Unix五种IO模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Reactor和Proactor模式"><span class="nav-number">1.5.</span> <span class="nav-text">Reactor和Proactor模式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NIO"><span class="nav-number">2.</span> <span class="nav-text">NIO</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#NIO与传统IO的区别"><span class="nav-number">2.1.</span> <span class="nav-text">NIO与传统IO的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#java-nio基本概念"><span class="nav-number">2.2.</span> <span class="nav-text">java nio基本概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#java-nio的实现"><span class="nav-number">2.3.</span> <span class="nav-text">java nio的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#selector"><span class="nav-number">2.3.1.</span> <span class="nav-text">selector</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#channel"><span class="nav-number">2.3.2.</span> <span class="nav-text">channel</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Buffer"><span class="nav-number">2.3.3.</span> <span class="nav-text">Buffer</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#在java-nio中同步非阻塞的实现方式"><span class="nav-number">2.4.</span> <span class="nav-text">在java nio中同步非阻塞的实现方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#select、poll、epoll"><span class="nav-number">2.5.</span> <span class="nav-text">select、poll、epoll</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AIO"><span class="nav-number">3.</span> <span class="nav-text">AIO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#从JAVA-源码分析NIO"><span class="nav-number">4.</span> <span class="nav-text">从JAVA 源码分析NIO</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#用NIO-实现一个简单的服务器"><span class="nav-number">4.1.</span> <span class="nav-text">用NIO 实现一个简单的服务器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Selector-open"><span class="nav-number">4.2.</span> <span class="nav-text">Selector.open()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pollWrapper"><span class="nav-number">4.3.</span> <span class="nav-text">pollWrapper</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#serverSocketChannel-register"><span class="nav-number">4.4.</span> <span class="nav-text">serverSocketChannel.register()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#doSelect"><span class="nav-number">4.5.</span> <span class="nav-text">doSelect()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#wakeUp"><span class="nav-number">4.6.</span> <span class="nav-text">wakeUp()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll-实现原理"><span class="nav-number">5.</span> <span class="nav-text">epoll 实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#流和channel的不同"><span class="nav-number">6.</span> <span class="nav-text">流和channel的不同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Reactor模型-反应堆模型"><span class="nav-number">7.</span> <span class="nav-text">Reactor模型(反应堆模型)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参考"><span class="nav-number">8.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        	<div class="copyright"> &copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">May</span>

  

  
</div>












        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
















  
  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.4.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.2"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
